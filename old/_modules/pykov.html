

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>pykov &mdash; Pykov v1.0 documentation</title>
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../_static/logo.ico"/>
    <link rel="top" title="Pykov v1.0 documentation" href="../index.html" />
    <link rel="up" title="Module code" href="index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li><a href="../index.html">Pykov v1.0 documentation</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for pykov</h1><div class="highlight"><pre>
<span class="c"># -*- coding: utf-8 -*-</span>

<span class="c"># PyKov is Python package for the creation, manipulation and study of Markov</span>
<span class="c"># Chains.</span>
<span class="c"># Copyright (C) 2011  Riccardo Scalco</span>
<span class="c"># </span>
<span class="c"># This program is free software: you can redistribute it and/or modify</span>
<span class="c"># it under the terms of the GNU General Public License as published by</span>
<span class="c"># the Free Software Foundation, either version 3 of the License, or</span>
<span class="c"># (at your option) any later version.</span>
<span class="c"># </span>
<span class="c"># This program is distributed in the hope that it will be useful,</span>
<span class="c"># but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c"># GNU General Public License for more details.</span>
<span class="c"># </span>
<span class="c"># You should have received a copy of the GNU General Public License</span>
<span class="c"># along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>

<span class="c"># Email: riccardo.scalco@gmail.com</span>

<span class="sd">&quot;&quot;&quot;Pykov documentation.</span>

<span class="sd">.. module:: A Python module for finite Markov chains.</span>
<span class="sd">   :platform: Unix, Windows, Mac</span>

<span class="sd">.. moduleauthor::</span>
<span class="sd">   Riccardo Scalco &lt;riccardo.scalco@gmail.com&gt;</span>

<span class="sd">&quot;&quot;&quot;</span>


<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">math</span>

<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">import</span> <span class="nn">pysparse</span>
<span class="c">#import networkx</span>

<span class="n">__date__</span> <span class="o">=</span> <span class="s">&#39;Jan 2012&#39;</span>

<span class="n">__version__</span> <span class="o">=</span> <span class="mf">1.0</span>

<span class="n">__license__</span> <span class="o">=</span> <span class="s">&#39;GNU General Public License Version 3&#39;</span> 

<span class="n">__authors__</span> <span class="o">=</span> <span class="s">&#39;Riccardo Scalco&#39;</span>

<span class="n">__many_thanks_to__</span> <span class="o">=</span> <span class="s">&#39;Sandra Steiner&#39;</span>

<span class="k">def</span> <span class="nf">_del_cache</span><span class="p">(</span><span class="n">fn</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Delete cache.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c">#try:</span>
        <span class="c">#    del self.__dict__[&quot;states&quot;]</span>
        <span class="c">#except KeyError:</span>
        <span class="c">#    pass</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">del</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_states</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">del</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_succ</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">del</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_pred</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">del</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_steady</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">del</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_guess</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">del</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fundamental_matrix</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">return</span> <span class="n">fn</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">wrapper</span>

<span class="k">class</span> <span class="nc">PykovError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Exception definition form Pykov Errors.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

<div class="viewcode-block" id="Vector"><a class="viewcode-back" href="../getting_started.html#pykov.Vector">[docs]</a><span class="k">class</span> <span class="nc">Vector</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &gt;&gt;&gt; pykov.Vector({&#39;A&#39;:.3, &#39;B&#39;:.7})</span>
<span class="sd">        {&#39;A&#39;:.3, &#39;B&#39;:.7}</span>
<span class="sd">        &gt;&gt;&gt; pykov.Vector(A=.3, B=.7)</span>
<span class="sd">        {&#39;A&#39;:.3, &#39;B&#39;:.7}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c">#dict.__init__(self)</span>
        <span class="k">if</span> <span class="n">data</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &gt;&gt;&gt; q = pykov.Vector(C=.4, B=.6)</span>
<span class="sd">        &gt;&gt;&gt; q[&#39;C&#39;]</span>
<span class="sd">        0.4</span>
<span class="sd">        &gt;&gt;&gt; q[&#39;Z&#39;]</span>
<span class="sd">        0.0</span>
<span class="sd">        &gt;&gt;&gt; &#39;Z&#39; in q</span>
<span class="sd">        False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">dict</span><span class="o">.</span><span class="n">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">0.0</span>
    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &gt;&gt;&gt; q = pykov.Vector(C=.4, B=.6)</span>
<span class="sd">        &gt;&gt;&gt; q[&#39;Z&#39;]=.2</span>
<span class="sd">        &gt;&gt;&gt; q</span>
<span class="sd">        {&#39;C&#39;: 0.4, &#39;B&#39;: 0.6, &#39;Z&#39;: 0.2}</span>
<span class="sd">        &gt;&gt;&gt; q[&#39;Z&#39;]=0</span>
<span class="sd">        &gt;&gt;&gt; q</span>
<span class="sd">        {&#39;C&#39;: 0.4, &#39;B&#39;: 0.6}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">value</span><span class="p">:</span>
            <span class="nb">dict</span><span class="o">.</span><span class="n">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">del</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">M</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &gt;&gt;&gt; p = pykov.Vector(A=.3, B=.7)</span>
<span class="sd">        &gt;&gt;&gt; p * 3</span>
<span class="sd">        {&#39;A&#39;: 0.9, &#39;B&#39;: 2.1}</span>
<span class="sd">        &gt;&gt;&gt; q = pykov.Vector(C=.5, B=.5)</span>
<span class="sd">        &gt;&gt;&gt; p * q</span>
<span class="sd">        0.35</span>
<span class="sd">        &gt;&gt;&gt; T = pykov.Matrix({(&#39;A&#39;,&#39;B&#39;): .3, (&#39;A&#39;,&#39;A&#39;): .7, (&#39;B&#39;,&#39;A&#39;): 1.})</span>
<span class="sd">        &gt;&gt;&gt; p * T</span>
<span class="sd">        {&#39;A&#39;: 0.91, &#39;B&#39;: 0.09}</span>
<span class="sd">        &gt;&gt;&gt; T * p</span>
<span class="sd">        {&#39;A&#39;: 0.42, &#39;B&#39;: 0.3}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="nb">float</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">state</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
                <span class="n">result</span><span class="p">[</span><span class="n">state</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span> <span class="o">*</span> <span class="n">M</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">Matrix</span><span class="p">):</span>
            <span class="n">e2p</span><span class="p">,</span> <span class="n">p2e</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">_el2pos_</span><span class="p">()</span> 
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_toarray</span><span class="p">(</span><span class="n">e2p</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
            <span class="n">M</span><span class="o">.</span><span class="n">_ll_mat_</span><span class="p">(</span><span class="n">e2p</span><span class="p">)</span><span class="o">.</span><span class="n">matvec_transp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">()</span>
            <span class="n">result</span><span class="o">.</span><span class="n">_fromarray</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">e2p</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">Vector</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">state</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
                <span class="n">result</span> <span class="o">+=</span> <span class="n">value</span> <span class="o">*</span> <span class="n">M</span><span class="p">[</span><span class="n">state</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;unsupported operand type(s) for *:&#39;</span><span class="o">+</span>
                            <span class="s">&#39; </span><span class="se">\&#39;</span><span class="s">Vector</span><span class="se">\&#39;</span><span class="s"> and &#39;</span><span class="o">+</span><span class="nb">repr</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">M</span><span class="p">))[</span><span class="mi">7</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">M</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &gt;&gt;&gt; p = pykov.Vector(A=.3, B=.7)</span>
<span class="sd">        &gt;&gt;&gt; 3 * p </span>
<span class="sd">        {&#39;A&#39;: 0.9, &#39;B&#39;: 2.1}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="nb">float</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">state</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
                <span class="n">result</span><span class="p">[</span><span class="n">state</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span> <span class="o">*</span> <span class="n">M</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;unsupported operand type(s) for *: &#39;</span><span class="o">+</span>
                            <span class="nb">repr</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">M</span><span class="p">))[</span><span class="mi">7</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="s">&#39; and </span><span class="se">\&#39;</span><span class="s">Vector</span><span class="se">\&#39;</span><span class="s">&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &gt;&gt;&gt; p = pykov.Vector(A=.3, B=.7)</span>
<span class="sd">        &gt;&gt;&gt; q = pykov.Vector(C=.5, B=.5)</span>
<span class="sd">        &gt;&gt;&gt; p + q</span>
<span class="sd">        {&#39;A&#39;: 0.3, &#39;C&#39;: 0.5, &#39;B&#39;: 1.2}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">Vector</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                <span class="n">result</span><span class="p">[</span><span class="n">state</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">state</span><span class="p">]</span> <span class="o">+</span> <span class="n">v</span><span class="p">[</span><span class="n">state</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;unsupported operand type(s) for +:&#39;</span><span class="o">+</span>
                            <span class="s">&#39; </span><span class="se">\&#39;</span><span class="s">Vector</span><span class="se">\&#39;</span><span class="s"> and &#39;</span><span class="o">+</span><span class="nb">repr</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">))[</span><span class="mi">7</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &gt;&gt;&gt; p = pykov.Vector(A=.3, B=.7)</span>
<span class="sd">        &gt;&gt;&gt; q = pykov.Vector(C=.5, B=.5)</span>
<span class="sd">        &gt;&gt;&gt; p - q</span>
<span class="sd">        {&#39;A&#39;: 0.3, &#39;C&#39;: -0.5, &#39;B&#39;: 0.2}</span>
<span class="sd">        &gt;&gt;&gt; q - p</span>
<span class="sd">        {&#39;A&#39;: -0.3, &#39;C&#39;: 0.5, &#39;B&#39;: -0.2}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">Vector</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                <span class="n">result</span><span class="p">[</span><span class="n">state</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">state</span><span class="p">]</span> <span class="o">-</span> <span class="n">v</span><span class="p">[</span><span class="n">state</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;unsupported operand type(s) for -:&#39;</span><span class="o">+</span>
                            <span class="s">&#39; </span><span class="se">\&#39;</span><span class="s">Vector</span><span class="se">\&#39;</span><span class="s"> and &#39;</span><span class="o">+</span><span class="nb">repr</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">))[</span><span class="mi">7</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">_toarray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">el2pos</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &gt;&gt;&gt; p = pykov.Vector(A=.3, B=.7)</span>
<span class="sd">        &gt;&gt;&gt; el2pos = {&#39;A&#39;: 1, &#39;B&#39;: 0}</span>
<span class="sd">        &gt;&gt;&gt; v = p._toarray(el2pos)</span>
<span class="sd">        &gt;&gt;&gt; v</span>
<span class="sd">        array([ 0.7,  0.3])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">el2pos</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
            <span class="n">p</span><span class="p">[</span><span class="n">el2pos</span><span class="p">[</span><span class="n">key</span><span class="p">]]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">return</span> <span class="n">p</span>
    <span class="k">def</span> <span class="nf">_fromarray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arr</span><span class="p">,</span> <span class="n">el2pos</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &gt;&gt;&gt; p = pykov.Vector()</span>
<span class="sd">        &gt;&gt;&gt; el2pos = {&#39;A&#39;: 1, &#39;B&#39;: 0}</span>
<span class="sd">        &gt;&gt;&gt; v = numpy.array([ 0.7,  0.3])</span>
<span class="sd">        &gt;&gt;&gt; p._fromarray(v,el2pos)</span>
<span class="sd">        &gt;&gt;&gt; p</span>
<span class="sd">        {&#39;A&#39;: 0.3, &#39;B&#39;: 0.7}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">elem</span><span class="p">,</span> <span class="n">pos</span> <span class="ow">in</span> <span class="n">el2pos</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">elem</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">None</span>
<div class="viewcode-block" id="Vector.sort"><a class="viewcode-back" href="../getting_started.html#pykov.Vector.sort">[docs]</a>    <span class="k">def</span> <span class="nf">sort</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sort according the probability.</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; p = pykov.Vector({&#39;A&#39;:.3, &#39;B&#39;:.1, &#39;C&#39;:.6})</span>
<span class="sd">        &gt;&gt;&gt; p.sort()</span>
<span class="sd">        [(&#39;B&#39;, 0.1), (&#39;A&#39;, 0.3), (&#39;C&#39;, 0.6)]</span>
<span class="sd">        &gt;&gt;&gt; p.sort(reverse=True)</span>
<span class="sd">        [(&#39;C&#39;, 0.6), (&#39;A&#39;, 0.3), (&#39;B&#39;, 0.1)]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="n">res</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">lst</span><span class="p">:</span> <span class="n">lst</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="n">reverse</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span></div>
<div class="viewcode-block" id="Vector.normalize"><a class="viewcode-back" href="../getting_started.html#pykov.Vector.normalize">[docs]</a>    <span class="k">def</span> <span class="nf">normalize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Normalize the vector so that the entries sum is 1.</span>

<span class="sd">        &gt;&gt;&gt; p = pykov.Vector({&#39;A&#39;:3, &#39;B&#39;:1, &#39;C&#39;:6})</span>
<span class="sd">        &gt;&gt;&gt; p.normalize()</span>
<span class="sd">        &gt;&gt;&gt; p</span>
<span class="sd">        {&#39;A&#39;: 0.3, &#39;C&#39;: 0.6, &#39;B&#39;: 0.1}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">/</span><span class="n">s</span></div>
<div class="viewcode-block" id="Vector.choose"><a class="viewcode-back" href="../getting_started.html#pykov.Vector.choose">[docs]</a>    <span class="k">def</span> <span class="nf">choose</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Choose a state according to its probability.</span>

<span class="sd">        &gt;&gt;&gt; p = pykov.Vector(A=.3, B=.7)</span>
<span class="sd">        &gt;&gt;&gt; p.choose()</span>
<span class="sd">        &#39;B&#39;</span>

<span class="sd">        .. seealso::</span>

<span class="sd">           `Kevin Parks recipe &lt;http://code.activestate.com/recipes/117241/&gt;`_</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">state</span><span class="p">,</span> <span class="n">prob</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">prob</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="n">prob</span>
        <span class="k">return</span> <span class="n">state</span></div>
<div class="viewcode-block" id="Vector.entropy"><a class="viewcode-back" href="../getting_started.html#pykov.Vector.entropy">[docs]</a>    <span class="k">def</span> <span class="nf">entropy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the entropy.</span>

<span class="sd">        .. math::</span>
<span class="sd">        </span>
<span class="sd">           H(p) = \sum_i p_i \ln p_i</span>

<span class="sd">        .. seealso::</span>
<span class="sd">        </span>
<span class="sd">           Khinchin, A. I.</span>
<span class="sd">           Mathematical Foundations of Information Theory</span>
<span class="sd">           Dover, 1957.</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; p = pykov.Vector(A=.3, B=.7)</span>
<span class="sd">        &gt;&gt;&gt; p.entropy()</span>
<span class="sd">        0.6108643020548935</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="o">-</span><span class="nb">sum</span><span class="p">([</span><span class="n">v</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">itervalues</span><span class="p">()])</span></div>
<div class="viewcode-block" id="Vector.relative_entropy"><a class="viewcode-back" href="../getting_started.html#pykov.Vector.relative_entropy">[docs]</a>    <span class="k">def</span> <span class="nf">relative_entropy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">p</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the Kullback-Leibler distance.</span>
<span class="sd">        </span>
<span class="sd">        .. math::</span>
<span class="sd">           </span>
<span class="sd">           d(q,p) = \sum_i q_i \ln (q_i/p_i)</span>
<span class="sd">        </span>
<span class="sd">        .. note::</span>

<span class="sd">           The Kullback-Leibler distance is not symmetric.</span>

<span class="sd">        &gt;&gt;&gt; p = pykov.Vector(A=.3, B=.7)</span>
<span class="sd">        &gt;&gt;&gt; q = pykov.Vector(A=.4, B=.6)</span>
<span class="sd">        &gt;&gt;&gt; p.relative_entropy(q)</span>
<span class="sd">        0.02160085414354654</span>
<span class="sd">        &gt;&gt;&gt; q.relative_entropy(p)</span>
<span class="sd">        0.022582421084357485</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">states</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">([</span><span class="bp">self</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">/</span><span class="n">p</span><span class="p">[</span><span class="n">s</span><span class="p">])</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">states</span><span class="p">])</span></div>
<div class="viewcode-block" id="Vector.copy"><a class="viewcode-back" href="../getting_started.html#pykov.Vector.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a shallow copy.</span>

<span class="sd">        &gt;&gt;&gt; p = pykov.Vector(A=.3, B=.7)</span>
<span class="sd">        &gt;&gt;&gt; q = p.copy()</span>
<span class="sd">        &gt;&gt;&gt; p[&#39;C&#39;] = 1.</span>
<span class="sd">        &gt;&gt;&gt; q</span>
<span class="sd">        {&#39;A&#39;: 0.3, &#39;B&#39;: 0.7}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Vector</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>
<div class="viewcode-block" id="Vector.sum"><a class="viewcode-back" href="../getting_started.html#pykov.Vector.sum">[docs]</a>    <span class="k">def</span> <span class="nf">sum</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sum the values.</span>

<span class="sd">        &gt;&gt;&gt; p = pykov.Vector(A=.3, B=.7)</span>
<span class="sd">        &gt;&gt;&gt; p.sum()</span>
<span class="sd">        1.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">itervalues</span><span class="p">()))</span></div>
<div class="viewcode-block" id="Vector.dist"><a class="viewcode-back" href="../getting_started.html#pykov.Vector.dist">[docs]</a>    <span class="k">def</span> <span class="nf">dist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the distance between the two probability vectors.</span>
<span class="sd">        </span>
<span class="sd">        .. math::</span>
<span class="sd">        </span>
<span class="sd">           d(q,p) = \sum_i |q_i - p_i|</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; p = pykov.Vector(A=.3, B=.7)</span>
<span class="sd">        &gt;&gt;&gt; q = pykov.Vector(C=.5, B=.5)</span>
<span class="sd">        &gt;&gt;&gt; q.dist(p)</span>
<span class="sd">        1.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">Vector</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                <span class="n">result</span> <span class="o">+=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">state</span><span class="p">]</span><span class="o">-</span><span class="bp">self</span><span class="p">[</span><span class="n">state</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">result</span>
</div></div>
<div class="viewcode-block" id="Matrix"><a class="viewcode-back" href="../getting_started.html#pykov.Matrix">[docs]</a><span class="k">class</span> <span class="nc">Matrix</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &gt;&gt;&gt; T = pykov.Matrix({(&#39;A&#39;,&#39;B&#39;): .3, (&#39;A&#39;,&#39;A&#39;): .7, (&#39;B&#39;,&#39;A&#39;): 1.})</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c">#dict.__init__(self)</span>
        <span class="k">if</span> <span class="n">data</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &gt;&gt;&gt; T = pykov.Matrix({(&#39;A&#39;,&#39;B&#39;): .3, (&#39;A&#39;,&#39;A&#39;): .7, (&#39;B&#39;,&#39;A&#39;): 1.})</span>
<span class="sd">        &gt;&gt;&gt; T[(&#39;A&#39;,&#39;B&#39;)]</span>
<span class="sd">        0.3</span>
<span class="sd">        &gt;&gt;&gt; T[&#39;A&#39;,&#39;B&#39;]</span>
<span class="sd">        0.3</span>
<span class="sd">        &gt;&gt;&gt; T[&#39;B&#39;,&#39;B&#39;]</span>
<span class="sd">        0.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">dict</span><span class="o">.</span><span class="n">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">0.0</span>
    <span class="nd">@_del_cache</span>
    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &gt;&gt;&gt; T = pykov.Matrix()</span>
<span class="sd">        &gt;&gt;&gt; T[(&#39;A&#39;,&#39;B&#39;)] = .3</span>
<span class="sd">        &gt;&gt;&gt; T</span>
<span class="sd">        {(&#39;A&#39;, &#39;B&#39;): 0.3}</span>
<span class="sd">        &gt;&gt;&gt; T[&#39;A&#39;,&#39;A&#39;] = .7</span>
<span class="sd">        &gt;&gt;&gt; T</span>
<span class="sd">        {(&#39;A&#39;, &#39;B&#39;): 0.3, (&#39;A&#39;, &#39;A&#39;): 0.7}</span>
<span class="sd">        &gt;&gt;&gt; T[&#39;B&#39;,&#39;B&#39;] = 0</span>
<span class="sd">        &gt;&gt;&gt; T</span>
<span class="sd">        {(&#39;A&#39;, &#39;B&#39;): 0.3, (&#39;A&#39;, &#39;A&#39;): 0.7}</span>
<span class="sd">        &gt;&gt;&gt; T[&#39;A&#39;,&#39;A&#39;] = 0</span>
<span class="sd">        &gt;&gt;&gt; T</span>
<span class="sd">        {(&#39;A&#39;, &#39;B&#39;): 0.3}</span>

<span class="sd">        &gt;&gt;&gt; T = pykov.Matrix({(&#39;A&#39;,&#39;B&#39;): 3, (&#39;A&#39;,&#39;A&#39;): 7, (&#39;B&#39;,&#39;A&#39;): .1})</span>
<span class="sd">        &gt;&gt;&gt; T.states()</span>
<span class="sd">        set([&#39;A&#39;, &#39;B&#39;])</span>
<span class="sd">        &gt;&gt;&gt; T[&#39;A&#39;,&#39;C&#39;]=1</span>
<span class="sd">        &gt;&gt;&gt; T.states()</span>
<span class="sd">        set([&#39;A&#39;, &#39;C&#39;, &#39;B&#39;])</span>
<span class="sd">        &gt;&gt;&gt; T[&#39;A&#39;,&#39;C&#39;]=0</span>
<span class="sd">        &gt;&gt;&gt; T.states()</span>
<span class="sd">        set([&#39;A&#39;, &#39;B&#39;])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">value</span><span class="p">:</span>
            <span class="nb">dict</span><span class="o">.</span><span class="n">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">del</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
    <span class="nd">@_del_cache</span>
    <span class="k">def</span> <span class="nf">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &gt;&gt;&gt; T = pykov.Matrix({(&#39;A&#39;,&#39;B&#39;): .3, (&#39;A&#39;,&#39;A&#39;): .7, (&#39;B&#39;,&#39;A&#39;): 1.})</span>
<span class="sd">        &gt;&gt;&gt; del(T[&#39;B&#39;, &#39;A&#39;])</span>
<span class="sd">        &gt;&gt;&gt; T</span>
<span class="sd">        {(&#39;A&#39;, &#39;B&#39;): 0.3, (&#39;A&#39;, &#39;A&#39;): 0.7}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">dict</span><span class="o">.</span><span class="n">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
    <span class="nd">@_del_cache</span>
    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove specified key and return the corresponding value.</span>
<span class="sd">        See: help(dict.pop)</span>

<span class="sd">        &gt;&gt;&gt; T = pykov.Matrix({(&#39;A&#39;,&#39;B&#39;): .3, (&#39;A&#39;,&#39;A&#39;): .7, (&#39;B&#39;,&#39;A&#39;): 1.})</span>
<span class="sd">        &gt;&gt;&gt; T.pop((&#39;A&#39;,&#39;B&#39;))</span>
<span class="sd">        0.3</span>
<span class="sd">        &gt;&gt;&gt; T</span>
<span class="sd">        {(&#39;B&#39;, &#39;A&#39;): 1.0, (&#39;A&#39;, &#39;A&#39;): 0.7}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span>  <span class="nb">dict</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
    <span class="nd">@_del_cache</span>
    <span class="k">def</span> <span class="nf">popitem</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove and return some (key, value) pair as a 2-tuple.</span>
<span class="sd">        See: help(dict.popitem)</span>

<span class="sd">        &gt;&gt;&gt; T = pykov.Matrix({(&#39;A&#39;,&#39;B&#39;): .3, (&#39;A&#39;,&#39;A&#39;): .7, (&#39;B&#39;,&#39;A&#39;): 1.})</span>
<span class="sd">        &gt;&gt;&gt; T.popitem()</span>
<span class="sd">        ((&#39;B&#39;, &#39;A&#39;), 1.0)</span>
<span class="sd">        &gt;&gt;&gt; T</span>
<span class="sd">        {(&#39;A&#39;, &#39;B&#39;): 0.3, (&#39;A&#39;, &#39;A&#39;): 0.7}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span>  <span class="nb">dict</span><span class="o">.</span><span class="n">popitem</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="nd">@_del_cache</span>
    <span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove all keys.</span>
<span class="sd">        See: help(dict.clear)</span>

<span class="sd">        &gt;&gt;&gt; T = pykov.Matrix({(&#39;A&#39;,&#39;B&#39;): .3, (&#39;A&#39;,&#39;A&#39;): .7, (&#39;B&#39;,&#39;A&#39;): 1.})</span>
<span class="sd">        &gt;&gt;&gt; T.clear()</span>
<span class="sd">        &gt;&gt;&gt; T</span>
<span class="sd">        {}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">dict</span><span class="o">.</span><span class="n">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="nd">@_del_cache</span>
    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update with keys and their values present in other.</span>
<span class="sd">        See: help(dict.update)</span>

<span class="sd">        &gt;&gt;&gt; T = pykov.Matrix({(&#39;A&#39;,&#39;B&#39;): .3, (&#39;A&#39;,&#39;A&#39;): .7, (&#39;B&#39;,&#39;A&#39;): 1.})</span>
<span class="sd">        &gt;&gt;&gt; d = {(&#39;B&#39;, &#39;C&#39;):2}</span>
<span class="sd">        &gt;&gt;&gt; T.update(d)</span>
<span class="sd">        &gt;&gt;&gt; T</span>
<span class="sd">        {(&#39;B&#39;, &#39;A&#39;): 1.0, (&#39;B&#39;, &#39;C&#39;): 2, (&#39;A&#39;, &#39;B&#39;): 0.3, (&#39;A&#39;, &#39;A&#39;): 0.7}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">dict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
    <span class="nd">@_del_cache</span>
    <span class="k">def</span> <span class="nf">setdefault</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        See: help(dict.setdefault)</span>

<span class="sd">        &gt;&gt;&gt; T = pykov.Matrix({(&#39;A&#39;,&#39;B&#39;): .3, (&#39;A&#39;,&#39;A&#39;): .7, (&#39;B&#39;,&#39;A&#39;): 1.})</span>
<span class="sd">        &gt;&gt;&gt; T.setdefault((&#39;A&#39;,&#39;A&#39;),1)</span>
<span class="sd">        0.7</span>
<span class="sd">        &gt;&gt;&gt; T</span>
<span class="sd">        {(&#39;B&#39;, &#39;A&#39;): 1.0, (&#39;A&#39;, &#39;B&#39;): 0.3, (&#39;A&#39;, &#39;A&#39;): 0.7}</span>
<span class="sd">        &gt;&gt;&gt; T.setdefault((&#39;A&#39;,&#39;C&#39;),1)</span>
<span class="sd">        1</span>
<span class="sd">        &gt;&gt;&gt; T</span>
<span class="sd">        {(&#39;B&#39;, &#39;A&#39;): 1.0, (&#39;A&#39;, &#39;B&#39;): 0.3, (&#39;A&#39;, &#39;A&#39;): 0.7, (&#39;A&#39;, &#39;C&#39;): 1}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<div class="viewcode-block" id="Matrix.copy"><a class="viewcode-back" href="../getting_started.html#pykov.Matrix.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a shallow copy.</span>

<span class="sd">        &gt;&gt;&gt; T = pykov.Matrix({(&#39;A&#39;,&#39;B&#39;): .3, (&#39;A&#39;,&#39;A&#39;): .7, (&#39;B&#39;,&#39;A&#39;): 1.})</span>
<span class="sd">        &gt;&gt;&gt; W = T.copy()</span>
<span class="sd">        &gt;&gt;&gt; T[(&#39;B&#39;,&#39;B&#39;)] = 1.</span>
<span class="sd">        &gt;&gt;&gt; W</span>
<span class="sd">        {(&#39;B&#39;, &#39;A&#39;): 1.0, (&#39;A&#39;, &#39;B&#39;): 0.3, (&#39;A&#39;, &#39;A&#39;): 0.7}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>
    <span class="k">def</span> <span class="nf">_ll_mat_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">el2pos</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s">&#39;&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">el2pos</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">ll_mat</span> <span class="o">=</span> <span class="n">pysparse</span><span class="o">.</span><span class="n">spmatrix</span><span class="o">.</span><span class="n">ll_mat</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s">&#39;&#39;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">el2pos</span><span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">el2pos</span><span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
                <span class="n">ll_mat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s">&#39;transpose&#39;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">el2pos</span><span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">el2pos</span><span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
                <span class="n">ll_mat</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ll_mat</span>
    <span class="k">def</span> <span class="nf">_from_ll_mat_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mat</span><span class="p">,</span> <span class="n">pos2el</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">mat</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">pos2el</span><span class="p">[</span><span class="n">ii</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span><span class="n">pos2el</span><span class="p">[</span><span class="n">ii</span><span class="p">[</span><span class="mi">1</span><span class="p">]]]</span> <span class="o">=</span> <span class="n">val</span>
        <span class="k">return</span> <span class="bp">None</span>
    <span class="k">def</span> <span class="nf">_numpy_mat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">el2pos</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a numpy.matrix object from a dictionary.</span>
<span class="sd">    </span>
<span class="sd">        -- Parameters --</span>
<span class="sd">        t_ij : the dict, values must be real numbers, keys should be tuples of</span>
<span class="sd">        two strings.</span>
<span class="sd">        el2pos : see _map()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">el2pos</span><span class="p">)</span>
        <span class="n">T</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">m</span><span class="p">,</span> <span class="n">m</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
            <span class="n">T</span><span class="p">[</span><span class="n">el2pos</span><span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">el2pos</span><span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">]]]</span> <span class="o">=</span> <span class="n">v</span>
        <span class="k">return</span> <span class="n">T</span>
    
    <span class="k">def</span> <span class="nf">_from_numpy_mat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">pos2el</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a dictionary from a numpy.matrix object.</span>
<span class="sd">    </span>
<span class="sd">        -- Parameters --</span>
<span class="sd">        T : the numpy.matrix.</span>
<span class="sd">        pos2el : see _map()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">T</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">T</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]:</span>
                    <span class="bp">self</span><span class="p">[(</span><span class="n">pos2el</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">pos2el</span><span class="p">[</span><span class="n">j</span><span class="p">])]</span> <span class="o">=</span> <span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">None</span>
    <span class="k">def</span> <span class="nf">_el2pos_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">el2pos</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">pos2el</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">pos</span><span class="p">,</span><span class="n">element</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">())):</span>
            <span class="n">el2pos</span><span class="p">[</span><span class="n">element</span><span class="p">]</span> <span class="o">=</span> <span class="n">pos</span>
            <span class="n">pos2el</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">element</span>
        <span class="k">return</span> <span class="n">el2pos</span><span class="p">,</span> <span class="n">pos2el</span>
    <span class="c">#def _pos2el_(self):</span>
    <span class="c">#    &quot;&quot;&quot;</span>
    <span class="c">#    &quot;&quot;&quot;</span>
    <span class="c">#    pos2el = {}</span>
    <span class="c">#    for pos,element in enumerate(list(self.states())):</span>
    <span class="c">#        pos2el[pos] = element</span>
    <span class="c">#    return pos2el</span>
<div class="viewcode-block" id="Matrix.stochastic"><a class="viewcode-back" href="../getting_started.html#pykov.Matrix.stochastic">[docs]</a>    <span class="k">def</span> <span class="nf">stochastic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make a right stochastic matrix.</span>

<span class="sd">        Set the sum of every row equal to one,</span>
<span class="sd">        raise ``PykovError`` if it is not possible.</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; T = pykov.Matrix({(&#39;A&#39;,&#39;B&#39;): 3, (&#39;A&#39;,&#39;A&#39;): 7, (&#39;B&#39;,&#39;A&#39;): .2})</span>
<span class="sd">        &gt;&gt;&gt; T.stochastic()</span>
<span class="sd">        &gt;&gt;&gt; T</span>
<span class="sd">        {(&#39;B&#39;, &#39;A&#39;): 1.0, (&#39;A&#39;, &#39;B&#39;): 0.3, (&#39;A&#39;, &#39;A&#39;): 0.7}</span>
<span class="sd">        &gt;&gt;&gt; T[(&#39;A&#39;,&#39;C&#39;)]=1</span>
<span class="sd">        &gt;&gt;&gt; T.stochastic()</span>
<span class="sd">        pykov.PykovError: &#39;Zero links from node C&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">succ</span><span class="p">()</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
            <span class="n">summ</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
            <span class="k">if</span> <span class="n">summ</span><span class="p">:</span>
                <span class="n">s</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">summ</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">PykovError</span><span class="p">(</span><span class="s">&#39;Zero links from state &#39;</span><span class="o">+</span><span class="n">k</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">/</span><span class="n">s</span><span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span></div>
<div class="viewcode-block" id="Matrix.pred"><a class="viewcode-back" href="../getting_started.html#pykov.Matrix.pred">[docs]</a>    <span class="k">def</span> <span class="nf">pred</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the precedessors of a state (if not indicated, of all states).</span>
<span class="sd">        In Matrix notation: return the coloum of the indicated state.</span>

<span class="sd">        &gt;&gt;&gt; T = pykov.Matrix({(&#39;A&#39;,&#39;B&#39;): .3, (&#39;A&#39;,&#39;A&#39;): .7, (&#39;B&#39;,&#39;A&#39;): 1.})</span>
<span class="sd">        &gt;&gt;&gt; T.pred()</span>
<span class="sd">        {&#39;A&#39;: {&#39;A&#39;: 0.7, &#39;B&#39;: 1.0}, &#39;B&#39;: {&#39;A&#39;: 0.3}}</span>
<span class="sd">        &gt;&gt;&gt; T.pred(&#39;A&#39;)</span>
<span class="sd">        {&#39;A&#39;: 0.7, &#39;B&#39;: 1.0}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">key</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pred</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pred</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pred</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">state</span><span class="p">,</span> <span class="n">Vector</span><span class="p">())</span> <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">()])</span>
            <span class="k">for</span> <span class="n">link</span><span class="p">,</span> <span class="n">probability</span> <span class="ow">in</span>  <span class="bp">self</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_pred</span><span class="p">[</span><span class="n">link</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="n">link</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">probability</span>
            <span class="k">if</span> <span class="n">key</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pred</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pred</span></div>
<div class="viewcode-block" id="Matrix.succ"><a class="viewcode-back" href="../getting_started.html#pykov.Matrix.succ">[docs]</a>    <span class="k">def</span> <span class="nf">succ</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the successors of a state (if not indicated, of all states).</span>
<span class="sd">        In Matrix notation: return the row of the indicated state.</span>

<span class="sd">        &gt;&gt;&gt; T = pykov.Matrix({(&#39;A&#39;,&#39;B&#39;): .3, (&#39;A&#39;,&#39;A&#39;): .7, (&#39;B&#39;,&#39;A&#39;): 1.})</span>
<span class="sd">        &gt;&gt;&gt; T.succ()</span>
<span class="sd">        {&#39;A&#39;: {&#39;A&#39;: 0.7, &#39;B&#39;: 0.3}, &#39;B&#39;: {&#39;A&#39;: 1.0}}</span>
<span class="sd">        &gt;&gt;&gt; T.succ(&#39;A&#39;)</span>
<span class="sd">        {&#39;A&#39;: 0.7, &#39;B&#39;: 0.3}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">key</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_succ</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_succ</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_succ</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">state</span><span class="p">,</span> <span class="n">Vector</span><span class="p">())</span> <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">()])</span>
            <span class="k">for</span> <span class="n">link</span><span class="p">,</span> <span class="n">probability</span> <span class="ow">in</span>  <span class="bp">self</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_succ</span><span class="p">[</span><span class="n">link</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">link</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">probability</span>
            <span class="k">if</span> <span class="n">key</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_succ</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_succ</span>
<span class="c">#    def remove(self, state):</span>
<span class="c">#        &quot;&quot;&quot;</span>
<span class="c">#        Return a copy of the Chain, without the indicated state.</span>
<span class="c">#        </span>
<span class="c">#        All the links where the state appears are deleted, so that the result</span>
<span class="c">#        will not be in general a stochastic matrix.</span>
<span class="c">#</span>
<span class="c">#        Example</span>
<span class="c">#        -------</span>
<span class="c">#        &gt;&gt;&gt; T = pykov.Matrix({(&#39;A&#39;,&#39;B&#39;): .3, (&#39;A&#39;,&#39;A&#39;): .7, (&#39;B&#39;,&#39;A&#39;): 1.})</span>
<span class="c">#        &gt;&gt;&gt; Z = T.remove(&#39;B&#39;)</span>
<span class="c">#        &gt;&gt;&gt; Z</span>
<span class="c">#        {(&#39;A&#39;, &#39;A&#39;): 0.7}</span>
<span class="c">#        &quot;&quot;&quot;</span>
<span class="c">#        return Matrix(dict([(key, value) for key, value in self.iteritems() if</span>
<span class="c">#               state not in key]))</span></div>
<div class="viewcode-block" id="Matrix.remove"><a class="viewcode-back" href="../getting_started.html#pykov.Matrix.remove">[docs]</a>    <span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">states</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a copy of the Chain, without the indicated states.</span>

<span class="sd">        .. warning::</span>
<span class="sd">           </span>
<span class="sd">           All the links where the states appear are deleted, so that the result</span>
<span class="sd">           will not be in general a stochastic matrix.</span>
<span class="sd">        ..</span>

<span class="sd">        &gt;&gt;&gt; T = pykov.Matrix({(&#39;A&#39;,&#39;B&#39;): .3, (&#39;A&#39;,&#39;A&#39;): .7, (&#39;B&#39;,&#39;A&#39;): 1.})</span>
<span class="sd">        &gt;&gt;&gt; T.remove([&#39;B&#39;])</span>
<span class="sd">        {(&#39;A&#39;, &#39;A&#39;): 0.7}</span>
<span class="sd">        &gt;&gt;&gt; T = pykov.Chain({(&#39;A&#39;,&#39;B&#39;): .3, (&#39;A&#39;,&#39;A&#39;): .7, (&#39;B&#39;,&#39;A&#39;): 1.,</span>
<span class="sd">                             (&#39;C&#39;,&#39;D&#39;): .5, (&#39;D&#39;,&#39;C&#39;): 1., (&#39;C&#39;,&#39;B&#39;): .5})</span>
<span class="sd">        &gt;&gt;&gt; T.remove_from([&#39;A&#39;,&#39;B&#39;])</span>
<span class="sd">        {(&#39;C&#39;, &#39;D&#39;): 0.5, (&#39;D&#39;, &#39;C&#39;): 1.0}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Matrix</span><span class="p">(</span><span class="nb">dict</span><span class="p">([(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iteritems</span><span class="p">()</span> <span class="k">if</span>
                       <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">states</span> <span class="ow">and</span> <span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">states</span><span class="p">]))</span>
<span class="c">#    @property</span>
<span class="c">#    def states(self):</span>
<span class="c">#        &quot;&quot;&quot;</span>
<span class="c">#        Example</span>
<span class="c">#        -------</span>
<span class="c">#        &gt;&gt;&gt; T = pykov.Matrix({(&#39;A&#39;,&#39;B&#39;): .3, (&#39;A&#39;,&#39;A&#39;): .7, (&#39;B&#39;,&#39;A&#39;): 1.})</span>
<span class="c">#        &gt;&gt;&gt; T.states</span>
<span class="c">#        set([&#39;A&#39;, &#39;B&#39;])</span>
<span class="c">#        &quot;&quot;&quot;</span>
<span class="c">#        try:</span>
<span class="c">#            return self.__dict__[&quot;states&quot;]</span>
<span class="c">#        except KeyError:</span>
<span class="c">#            self.__dict__[&quot;states&quot;] = set()</span>
<span class="c">#            for link in  self.iterkeys():</span>
<span class="c">#                self.states().add(link[0])</span>
<span class="c">#                self.states().add(link[1])</span>
<span class="c">#            return self.states()</span></div>
<div class="viewcode-block" id="Matrix.states"><a class="viewcode-back" href="../getting_started.html#pykov.Matrix.states">[docs]</a>    <span class="k">def</span> <span class="nf">states</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the set of states.</span>

<span class="sd">        &gt;&gt;&gt; T = pykov.Matrix({(&#39;A&#39;,&#39;B&#39;): .3, (&#39;A&#39;,&#39;A&#39;): .7, (&#39;B&#39;,&#39;A&#39;): 1.})</span>
<span class="sd">        &gt;&gt;&gt; T.states()</span>
<span class="sd">        set([&#39;A&#39;, &#39;B&#39;])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_states</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_states</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">link</span> <span class="ow">in</span>  <span class="bp">self</span><span class="o">.</span><span class="n">iterkeys</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_states</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">link</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_states</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">link</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_states</span></div>
    <span class="k">def</span> <span class="nf">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &gt;&gt;&gt; T = pykov.Matrix({(&#39;A&#39;,&#39;B&#39;): .3, (&#39;A&#39;,&#39;A&#39;): .7, (&#39;B&#39;,&#39;A&#39;): 1.})</span>
<span class="sd">        &gt;&gt;&gt; T * 3</span>
<span class="sd">        {(&#39;B&#39;, &#39;A&#39;): 3.0, (&#39;A&#39;, &#39;B&#39;): 0.9, (&#39;A&#39;, &#39;A&#39;): 2.1}</span>
<span class="sd">        &gt;&gt;&gt; p = pykov.Vector(A=.3, B=.7)</span>
<span class="sd">        &gt;&gt;&gt; T * p</span>
<span class="sd">        {&#39;A&#39;: 0.42, &#39;B&#39;: 0.3}</span>
<span class="sd">        &gt;&gt;&gt; W = pykov.Matrix({(&#39;N&#39;, &#39;M&#39;): 0.5, (&#39;M&#39;, &#39;N&#39;): 0.7,</span>
<span class="sd">                              (&#39;M&#39;, &#39;M&#39;): 0.3, (&#39;O&#39;, &#39;N&#39;): 0.5,</span>
<span class="sd">                              (&#39;O&#39;, &#39;O&#39;): 0.5, (&#39;N&#39;, &#39;O&#39;): 0.5})</span>
<span class="sd">        &gt;&gt;&gt; W * W</span>
<span class="sd">        {(&#39;N&#39;, &#39;M&#39;): 0.15, (&#39;M&#39;, &#39;N&#39;): 0.21, (&#39;M&#39;, &#39;O&#39;): 0.35,</span>
<span class="sd">         (&#39;M&#39;, &#39;M&#39;): 0.44, (&#39;O&#39;, &#39;M&#39;): 0.25, (&#39;O&#39;, &#39;N&#39;): 0.25,</span>
<span class="sd">         (&#39;O&#39;, &#39;O&#39;): 0.5, (&#39;N&#39;, &#39;O&#39;): 0.25, (&#39;N&#39;, &#39;N&#39;): 0.6}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">Vector</span><span class="p">):</span>
            <span class="n">e2p</span><span class="p">,</span> <span class="n">p2e</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_el2pos_</span><span class="p">()</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">_toarray</span><span class="p">(</span><span class="n">e2p</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ll_mat_</span><span class="p">(</span><span class="n">e2p</span><span class="p">)</span><span class="o">.</span><span class="n">matvec</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">()</span>
            <span class="n">result</span><span class="o">.</span><span class="n">_fromarray</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">e2p</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">Matrix</span><span class="p">):</span>
            <span class="n">e2p</span><span class="p">,</span> <span class="n">p2e</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_el2pos_</span><span class="p">()</span>
            <span class="n">C</span> <span class="o">=</span> <span class="n">pysparse</span><span class="o">.</span><span class="n">spmatrix</span><span class="o">.</span><span class="n">matrixmultiply</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ll_mat_</span><span class="p">(</span><span class="n">e2p</span><span class="p">),</span> <span class="n">v</span><span class="o">.</span><span class="n">_ll_mat_</span><span class="p">(</span><span class="n">e2p</span><span class="p">))</span>
            <span class="k">if</span> <span class="s">&#39;Chain&#39;</span> <span class="ow">in</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">):</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">Chain</span><span class="p">()</span>
            <span class="k">elif</span> <span class="s">&#39;Matrix&#39;</span> <span class="ow">in</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">):</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">()</span>
            <span class="n">res</span><span class="o">.</span><span class="n">_from_ll_mat_</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">p2e</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">res</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="nb">float</span><span class="p">):</span>
            <span class="k">return</span>  <span class="n">Matrix</span><span class="p">(</span><span class="nb">dict</span><span class="p">([(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="o">*</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">iteritems</span><span class="p">()]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;unsupported operand type(s) for *:&#39;</span><span class="o">+</span>
                            <span class="s">&#39; </span><span class="se">\&#39;</span><span class="s">Matrix</span><span class="se">\&#39;</span><span class="s"> and &#39;</span><span class="o">+</span><span class="nb">repr</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">))[</span><span class="mi">7</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &gt;&gt;&gt; T = pykov.Matrix({(&#39;A&#39;,&#39;B&#39;): .3, (&#39;A&#39;,&#39;A&#39;): .7, (&#39;B&#39;,&#39;A&#39;): 1.})</span>
<span class="sd">        &gt;&gt;&gt; 3 * T</span>
<span class="sd">        {(&#39;B&#39;, &#39;A&#39;): 3.0, (&#39;A&#39;, &#39;B&#39;): 0.9, (&#39;A&#39;, &#39;A&#39;): 2.1}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="nb">float</span><span class="p">):</span>
            <span class="k">return</span>  <span class="n">Matrix</span><span class="p">(</span><span class="nb">dict</span><span class="p">([(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="o">*</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">iteritems</span><span class="p">()]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;unsupported operand type(s) for *:&#39;</span><span class="o">+</span>
                            <span class="s">&#39; </span><span class="se">\&#39;</span><span class="s">Matrix</span><span class="se">\&#39;</span><span class="s"> and &#39;</span><span class="o">+</span><span class="nb">repr</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">))[</span><span class="mi">7</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">M</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &gt;&gt;&gt; T = pykov.Matrix({(&#39;A&#39;,&#39;B&#39;): .3, (&#39;A&#39;,&#39;A&#39;): .7, (&#39;B&#39;,&#39;A&#39;): 1.})</span>
<span class="sd">        &gt;&gt;&gt; I = pykov.Matrix({(&#39;A&#39;,&#39;A&#39;):1, (&#39;B&#39;,&#39;B&#39;):1})</span>
<span class="sd">        &gt;&gt;&gt; T + I</span>
<span class="sd">        {(&#39;B&#39;, &#39;A&#39;): 1.0, (&#39;A&#39;, &#39;B&#39;): 0.3, (&#39;A&#39;, &#39;A&#39;): 1.7, (&#39;B&#39;, &#39;B&#39;): 1.0}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">Matrix</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">link</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                <span class="n">result</span><span class="p">[</span><span class="n">link</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">link</span><span class="p">]</span> <span class="o">+</span> <span class="n">M</span><span class="p">[</span><span class="n">link</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;unsupported operand type(s) for +:&#39;</span><span class="o">+</span>
                            <span class="s">&#39; </span><span class="se">\&#39;</span><span class="s">Matrix</span><span class="se">\&#39;</span><span class="s"> and &#39;</span><span class="o">+</span><span class="nb">repr</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">M</span><span class="p">))[</span><span class="mi">7</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">M</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &gt;&gt;&gt; T = pykov.Matrix({(&#39;A&#39;,&#39;B&#39;): .3, (&#39;A&#39;,&#39;A&#39;): .7, (&#39;B&#39;,&#39;A&#39;): 1.})</span>
<span class="sd">        &gt;&gt;&gt; I = pykov.Matrix({(&#39;A&#39;,&#39;A&#39;):1, (&#39;B&#39;,&#39;B&#39;):1})</span>
<span class="sd">        &gt;&gt;&gt; T - I</span>
<span class="sd">        {(&#39;B&#39;, &#39;A&#39;): 1.0, (&#39;A&#39;, &#39;B&#39;): 0.3, (&#39;A&#39;, &#39;A&#39;): -0.3, (&#39;B&#39;, &#39;B&#39;): -1}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">Matrix</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">link</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                <span class="n">result</span><span class="p">[</span><span class="n">link</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">link</span><span class="p">]</span> <span class="o">-</span> <span class="n">M</span><span class="p">[</span><span class="n">link</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;unsupported operand type(s) for -:&#39;</span><span class="o">+</span>
                            <span class="s">&#39; </span><span class="se">\&#39;</span><span class="s">Matrix</span><span class="se">\&#39;</span><span class="s"> and &#39;</span><span class="o">+</span><span class="nb">repr</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">M</span><span class="p">))[</span><span class="mi">7</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<div class="viewcode-block" id="Matrix.trace"><a class="viewcode-back" href="../getting_started.html#pykov.Matrix.trace">[docs]</a>    <span class="k">def</span> <span class="nf">trace</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the Matrix trace.</span>

<span class="sd">        &gt;&gt;&gt; T = pykov.Matrix({(&#39;A&#39;,&#39;B&#39;): .3, (&#39;A&#39;,&#39;A&#39;): .7, (&#39;B&#39;,&#39;A&#39;): 1.})</span>
<span class="sd">        &gt;&gt;&gt; T.trace()</span>
<span class="sd">        0.7</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">([</span><span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">()])</span></div>
<div class="viewcode-block" id="Matrix.eye"><a class="viewcode-back" href="../getting_started.html#pykov.Matrix.eye">[docs]</a>    <span class="k">def</span> <span class="nf">eye</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the Identity Matrix.</span>

<span class="sd">        &gt;&gt;&gt; T = pykov.Matrix({(&#39;A&#39;,&#39;B&#39;): .3, (&#39;A&#39;,&#39;A&#39;): .7, (&#39;B&#39;,&#39;A&#39;): 1.})</span>
<span class="sd">        &gt;&gt;&gt; T.eye()</span>
<span class="sd">        {(&#39;A&#39;, &#39;A&#39;): 1., (&#39;B&#39;, &#39;B&#39;): 1.}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Matrix</span><span class="p">(</span><span class="nb">dict</span><span class="p">([((</span><span class="n">state</span><span class="p">,</span> <span class="n">state</span><span class="p">),</span> <span class="mf">1.</span><span class="p">)</span> <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">()]))</span></div>
<div class="viewcode-block" id="Matrix.ones"><a class="viewcode-back" href="../getting_started.html#pykov.Matrix.ones">[docs]</a>    <span class="k">def</span> <span class="nf">ones</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a ``Vector`` instance with entries equal to one.</span>

<span class="sd">        &gt;&gt;&gt; T = pykov.Matrix({(&#39;A&#39;,&#39;B&#39;): .3, (&#39;A&#39;,&#39;A&#39;): .7, (&#39;B&#39;,&#39;A&#39;): 1.})</span>
<span class="sd">        &gt;&gt;&gt; T.ones()</span>
<span class="sd">        {&#39;A&#39;: 1.0, &#39;B&#39;: 1.0}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Vector</span><span class="p">(</span><span class="nb">dict</span><span class="p">([(</span><span class="n">state</span><span class="p">,</span> <span class="mf">1.</span><span class="p">)</span> <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">()]))</span></div>
<div class="viewcode-block" id="Matrix.transpose"><a class="viewcode-back" href="../getting_started.html#pykov.Matrix.transpose">[docs]</a>    <span class="k">def</span> <span class="nf">transpose</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the transpose Matrix.</span>

<span class="sd">        &gt;&gt;&gt; T = pykov.Matrix({(&#39;A&#39;,&#39;B&#39;): .3, (&#39;A&#39;,&#39;A&#39;): .7, (&#39;B&#39;,&#39;A&#39;): 1.})</span>
<span class="sd">        &gt;&gt;&gt; T.transpose()</span>
<span class="sd">        {(&#39;B&#39;, &#39;A&#39;): 0.3, (&#39;A&#39;, &#39;B&#39;): 1.0, (&#39;A&#39;, &#39;A&#39;): 0.7}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Matrix</span><span class="p">(</span><span class="nb">dict</span><span class="p">([((</span><span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span>
               <span class="bp">self</span><span class="o">.</span><span class="n">iteritems</span><span class="p">()]))</span></div>
    <span class="k">def</span> <span class="nf">_BiCGSTAB</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">error</span><span class="o">=</span><span class="mf">1e-15</span><span class="p">,</span> <span class="n">maxit</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mf">1e9</span><span class="p">)):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Biconjugate gradient stabilized method.</span>
<span class="sd">        A * x = b</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        Van der Vorst, H. A. (1992). &quot;Bi-CGSTAB: A Fast and Smoothly Converging</span>
<span class="sd">        Variant of Bi-CG for the Solution of Nonsymmetric Linear Systems&quot;. SIAM</span>
<span class="sd">        Journal on Scientific and Statistical Computing 13: 631644.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">()))</span>
        <span class="n">e2p</span><span class="p">,</span> <span class="n">p2e</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_el2pos_</span><span class="p">()</span>
        <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_mat_</span><span class="p">(</span><span class="n">e2p</span><span class="p">)</span><span class="o">.</span><span class="n">to_csr</span><span class="p">()</span>
        <span class="n">bb</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">_toarray</span><span class="p">(</span><span class="n">e2p</span><span class="p">)</span>
        <span class="n">info</span><span class="p">,</span> <span class="n">niter</span><span class="p">,</span> <span class="n">relres</span> <span class="o">=</span> <span class="n">pysparse</span><span class="o">.</span><span class="n">itsolvers</span><span class="o">.</span><span class="n">bicgstab</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">bb</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">error</span><span class="p">,</span> <span class="n">maxit</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">info</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&#39;Sorry, not converged.&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">()</span>
        <span class="n">res</span><span class="o">.</span><span class="n">_fromarray</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">e2p</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span>
    <span class="k">def</span> <span class="nf">_UMPFPACKSolve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s">&#39;UMFPACK_A&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        UMFPACK ( U nsymmetric M ulti F Rontal PACK age)</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        method (see pysparse doc.):</span>
<span class="sd">            &quot;UMFPACK_A&quot;     :  \mathbf{A} x = b (default)</span>
<span class="sd">            &quot;UMFPACK_At&quot;    :  \mathbf{A}^T x = b</span>
<span class="sd">            &quot;UMFPACK_Pt_L&quot;  :  \mathbf{P}^T \mathbf{L} x = b</span>
<span class="sd">            &quot;UMFPACK_L&quot;     :  \mathbf{L} x = b</span>
<span class="sd">            &quot;UMFPACK_Lt_P&quot;  :  \mathbf{L}^T \mathbf{P} x = b</span>
<span class="sd">            &quot;UMFPACK_Lt&quot;    :  \mathbf{L}^T x = b</span>
<span class="sd">            &quot;UMFPACK_U_Qt&quot;  :  \mathbf{U} \mathbf{Q}^T x = b</span>
<span class="sd">            &quot;UMFPACK_U&quot;     :  \mathbf{U} x = b</span>
<span class="sd">            &quot;UMFPACK_Q_Ut   :  \mathbf{Q} \mathbf{U}^T x = b</span>
<span class="sd">            &quot;UMFPACK_Ut&quot;    :  \mathbf{U}^T x = b</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        A column pre-ordering strategy for the unsymmetric-pattern multifrontal</span>
<span class="sd">        method, T. A. Davis, ACM Transactions on Mathematical Software, vol 30,</span>
<span class="sd">        no. 2, June 2004, pp. 165-195.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">()))</span>
        <span class="n">e2p</span><span class="p">,</span> <span class="n">p2e</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_el2pos_</span><span class="p">()</span>
        <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_mat_</span><span class="p">(</span><span class="n">e2p</span><span class="p">)</span>
        <span class="n">bb</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">_toarray</span><span class="p">(</span><span class="n">e2p</span><span class="p">)</span>
        <span class="n">LU</span> <span class="o">=</span> <span class="n">pysparse</span><span class="o">.</span><span class="n">umfpack</span><span class="o">.</span><span class="n">factorize</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
        <span class="n">LU</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">bb</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">()</span>
        <span class="n">res</span><span class="o">.</span><span class="n">_fromarray</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">e2p</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span>
</div>
<div class="viewcode-block" id="Chain"><a class="viewcode-back" href="../getting_started.html#pykov.Chain">[docs]</a><span class="k">class</span> <span class="nc">Chain</span><span class="p">(</span><span class="n">Matrix</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>   
    
<div class="viewcode-block" id="Chain.move"><a class="viewcode-back" href="../getting_started.html#pykov.Chain.move">[docs]</a>    <span class="k">def</span> <span class="nf">move</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Do one step from the indicated state, and return the final state.</span>

<span class="sd">        &gt;&gt;&gt; T = pykov.Chain({(&#39;A&#39;,&#39;B&#39;): .3, (&#39;A&#39;,&#39;A&#39;): .7, (&#39;B&#39;,&#39;A&#39;): 1.})</span>
<span class="sd">        &gt;&gt;&gt; T.move(&#39;A&#39;)</span>
<span class="sd">        &#39;B&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">succ</span><span class="p">(</span><span class="n">state</span><span class="p">)</span><span class="o">.</span><span class="n">choose</span><span class="p">()</span> </div>
<div class="viewcode-block" id="Chain.pow"><a class="viewcode-back" href="../getting_started.html#pykov.Chain.pow">[docs]</a>    <span class="k">def</span> <span class="nf">pow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find the probability distribution after n steps, starting from an</span>
<span class="sd">        initial ``Vector``.</span>

<span class="sd">        &gt;&gt;&gt; T = pykov.Chain({(&#39;A&#39;,&#39;B&#39;): .3, (&#39;A&#39;,&#39;A&#39;): .7, (&#39;B&#39;,&#39;A&#39;): 1.})</span>
<span class="sd">        &gt;&gt;&gt; p = pykov.Vector(A=1)</span>
<span class="sd">        &gt;&gt;&gt; T.pow(p,3)</span>
<span class="sd">        {&#39;A&#39;: 0.7629999999999999, &#39;B&#39;: 0.23699999999999996}</span>
<span class="sd">        &gt;&gt;&gt; p * T * T * T</span>
<span class="sd">        {&#39;A&#39;: 0.7629999999999999, &#39;B&#39;: 0.23699999999999996}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">e2p</span><span class="p">,</span> <span class="n">p2e</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_el2pos_</span><span class="p">()</span>
        <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_mat_</span><span class="p">(</span><span class="n">e2p</span><span class="p">)</span><span class="o">.</span><span class="n">to_csr</span><span class="p">()</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">_toarray</span><span class="p">(</span><span class="n">e2p</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">e2p</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">A</span><span class="o">.</span><span class="n">matvec_transp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">()</span>
        <span class="n">res</span><span class="o">.</span><span class="n">_fromarray</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">e2p</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span>
    <span class="c">#def vector(self, data=None, **kwargs):</span>
    <span class="c">#    &quot;&quot;&quot;</span>
    <span class="c">#    Example</span>
    <span class="c">#    ------</span>
    <span class="c">#    See __init__ method of Vector class. </span>
    <span class="c">#    &gt;&gt;&gt; T = pykov.Chain({(&#39;A&#39;,&#39;B&#39;): .3, (&#39;A&#39;,&#39;A&#39;): .7, (&#39;B&#39;,&#39;A&#39;): 1.})</span>
    <span class="c">#    &gt;&gt;&gt; p = T.vector(A=1)</span>
    <span class="c">#    &quot;&quot;&quot;</span>
    <span class="c">#    if not data:</span>
    <span class="c">#        data = {}</span>
    <span class="c">#    data.update(kwargs)</span>
    <span class="c">#    res = Vector(data)</span>
    <span class="c">#    res._chain = self</span>
    <span class="c">#    return res</span>
<span class="c">#    def _GaussSeidel(self, p=None, error=1e-12):</span>
<span class="c">#        &quot;&quot;&quot;</span>
<span class="c">#        &quot;&quot;&quot;</span>
<span class="c">#        m = len(self.states())</span>
<span class="c">#        Q = self.eye() - self</span>
<span class="c">#        Q = Q.transpose()</span>
<span class="c">#        e2p, p2e = self._el2pos_()</span>
<span class="c">#        A = Q._ll_mat_(e2p)</span>
<span class="c">#        D_E = pysparse.spmatrix.ll_mat(m, m, m) #diagonal + lower diagonal part</span>
<span class="c">#        F = pysparse.spmatrix.ll_mat(m, m, m)   #upper diagonal part</span>
<span class="c">#        for k, v in A.items():</span>
<span class="c">#            if k[0] &gt;= k[1]:</span>
<span class="c">#                D_E[k] = v</span>
<span class="c">#            else:</span>
<span class="c">#                F[k] = -v</span>
<span class="c">#        F = F.to_csr()</span>
<span class="c">#        LU = pysparse.umfpack.factorize(D_E)</span>
<span class="c">#        if not p:</span>
<span class="c">#            if hasattr(self,&#39;_guess&#39;):</span>
<span class="c">#                p = self._guess</span>
<span class="c">#            else:</span>
<span class="c">#                p = Vector({random.sample(self.states(),1)[0]:1.})</span>
<span class="c">#        x = p._toarray(e2p)</span>
<span class="c">#        err = 1.</span>
<span class="c">#        n = 0</span>
<span class="c">#        xold = x.copy()</span>
<span class="c">#        b = numpy.zeros(m)</span>
<span class="c">#        while err &gt; error :</span>
<span class="c">#            F.matvec(x, b)</span>
<span class="c">#            LU.solve(b, x)</span>
<span class="c">#            n += 1</span>
<span class="c">#            if not n % 1000:</span>
<span class="c">#                err = numpy.linalg.norm( xold - x )</span>
<span class="c">#                print err</span>
<span class="c">#                xold = x.copy()</span>
<span class="c">#        res = Vector()</span>
<span class="c">#        res._fromarray(x, e2p)</span>
<span class="c">#        res.normalize()</span>
<span class="c">#        self._steady = res</span>
<span class="c">#        return res</span>
<span class="c">#    def steady_old(self):</span>
<span class="c">#        &quot;&quot;&quot;</span>
<span class="c">#        With the assumption of ergodicity, return the steady state.</span>
<span class="c">#        </span>
<span class="c">#        Maths</span>
<span class="c">#        -----</span>
<span class="c">#        Inverse iteration method:</span>
<span class="c">#        Q = T - 11</span>
<span class="c">#        Q.trasp * x = e_n</span>
<span class="c">#</span>
<span class="c">#        References</span>
<span class="c">#        ----------</span>
<span class="c">#        W. Stewart: Introduction to the Numerical Solution of Markov Chains,</span>
<span class="c">#        Princeton University Press, Chichester, West Sussex, 1994.</span>
<span class="c">#</span>
<span class="c">#        Example</span>
<span class="c">#        -------</span>
<span class="c">#        &gt;&gt;&gt; T = pykov.Chain({(&#39;A&#39;,&#39;B&#39;): .3, (&#39;A&#39;,&#39;A&#39;): .7, (&#39;B&#39;,&#39;A&#39;): 1.})</span>
<span class="c">#        &gt;&gt;&gt; T.steady()</span>
<span class="c">#        {&#39;A&#39;: 0.7692307692307676, &#39;B&#39;: 0.23076923076923028}</span>
<span class="c">#        &quot;&quot;&quot;</span>
<span class="c">#        try:</span>
<span class="c">#            return self._steady</span>
<span class="c">#        except AttributeError:</span>
<span class="c">#            e2p, p2e = self._el2pos_()</span>
<span class="c">#            M = self._ll_mat_(e2p)</span>
<span class="c">#            m = len(self.states())</span>
<span class="c">#            r = range(m)</span>
<span class="c">#            M.put([M[i,i]-1. for i in r],r,r)</span>
<span class="c">#            b = numpy.zeros(m)</span>
<span class="c">#            x = numpy.zeros(m)</span>
<span class="c">#            b[-1] = 1.</span>
<span class="c">#            LU = pysparse.umfpack.factorize(M)</span>
<span class="c">#            LU.solve(b, x, &quot;UMFPACK_At&quot;)</span>
<span class="c">#            res = Vector()</span>
<span class="c">#            res._fromarray(x, e2p)</span>
<span class="c">#            res.normalize()</span>
<span class="c">#            self._steady = res</span>
<span class="c">#            return res</span></div>
<div class="viewcode-block" id="Chain.steady"><a class="viewcode-back" href="../getting_started.html#pykov.Chain.steady">[docs]</a>    <span class="k">def</span> <span class="nf">steady</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        With the assumption of ergodicity, return the steady state.</span>
<span class="sd">        </span>
<span class="sd">        .. note::</span>
<span class="sd">           </span>
<span class="sd">           Inverse iteration method (P is the Markov chain)</span>

<span class="sd">           .. math::</span>
<span class="sd">           </span>
<span class="sd">              Q = \mathbf{I} - P</span>

<span class="sd">              Q^T x = e</span>

<span class="sd">              e = (0,0,\dots,0,1)</span>
<span class="sd">           ..</span>
<span class="sd">        ..</span>


<span class="sd">        .. seealso::</span>

<span class="sd">           W. Stewart: Introduction to the Numerical Solution of Markov Chains,</span>
<span class="sd">           Princeton University Press, Chichester, West Sussex, 1994.</span>

<span class="sd">        &gt;&gt;&gt; T = pykov.Chain({(&#39;A&#39;,&#39;B&#39;): .3, (&#39;A&#39;,&#39;A&#39;): .7, (&#39;B&#39;,&#39;A&#39;): 1.})</span>
<span class="sd">        &gt;&gt;&gt; T.steady()</span>
<span class="sd">        {&#39;A&#39;: 0.7692307692307676, &#39;B&#39;: 0.23076923076923028}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_steady</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">e2p</span><span class="p">,</span> <span class="n">p2e</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_el2pos_</span><span class="p">()</span>
            <span class="n">M</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_mat_</span><span class="p">(</span><span class="n">e2p</span><span class="p">,</span> <span class="s">&#39;transpose&#39;</span><span class="p">)</span>
            <span class="n">M</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">())</span>
            <span class="n">r</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
            <span class="n">M</span><span class="o">.</span><span class="n">put</span><span class="p">([</span><span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="mf">1.</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">r</span><span class="p">],</span><span class="n">r</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
            <span class="n">b</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">LU</span> <span class="o">=</span> <span class="n">pysparse</span><span class="o">.</span><span class="n">umfpack</span><span class="o">.</span><span class="n">factorize</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">SystemError</span><span class="p">:</span>  <span class="c">#not elegant this singular matrix error..</span>
                <span class="c"># really dirty trick ??</span>
                <span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">_machineEpsilon</span><span class="p">()</span>
                <span class="n">LU</span> <span class="o">=</span> <span class="n">pysparse</span><span class="o">.</span><span class="n">umfpack</span><span class="o">.</span><span class="n">factorize</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
            <span class="n">LU</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">()</span>
            <span class="n">res</span><span class="o">.</span><span class="n">_fromarray</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">e2p</span><span class="p">)</span>
            <span class="n">res</span><span class="o">.</span><span class="n">normalize</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_steady</span> <span class="o">=</span> <span class="n">res</span>
            <span class="k">return</span> <span class="n">res</span></div>
<div class="viewcode-block" id="Chain.entropy"><a class="viewcode-back" href="../getting_started.html#pykov.Chain.entropy">[docs]</a>    <span class="k">def</span> <span class="nf">entropy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the ``Chain`` entropy, calculated with the indicated probability</span>
<span class="sd">        Vector (the steady state by default).</span>

<span class="sd">        .. math::</span>
<span class="sd">        </span>
<span class="sd">           H_i = \sum_j P_{ij} \ln P_{ij}</span>
<span class="sd">           </span>
<span class="sd">           H = \sum \pi_i  H_i</span>

<span class="sd">        .. seealso::</span>
<span class="sd">        </span>
<span class="sd">           Khinchin, A. I.</span>
<span class="sd">           Mathematical Foundations of Information Theory</span>
<span class="sd">           Dover, 1957.</span>

<span class="sd">        &gt;&gt;&gt; T = pykov.Chain({(&#39;A&#39;,&#39;B&#39;): .3, (&#39;A&#39;,&#39;A&#39;): .7, (&#39;B&#39;,&#39;A&#39;): 1.})</span>
<span class="sd">        &gt;&gt;&gt; T.entropy()</span>
<span class="sd">        0.46989561696530169</span>

<span class="sd">        With normalization entropy belongs to [0,1]</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; T.entropy(norm=True)</span>
<span class="sd">        0.33895603665233132</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">p</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">steady</span><span class="p">()</span>
        <span class="n">H</span> <span class="o">=</span> <span class="mf">0.</span>
        <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">():</span>
            <span class="n">H</span> <span class="o">+=</span> <span class="n">p</span><span class="p">[</span><span class="n">state</span><span class="p">]</span> <span class="o">*</span> <span class="nb">sum</span><span class="p">([</span><span class="n">v</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">succ</span><span class="p">(</span><span class="n">state</span><span class="p">)</span><span class="o">.</span><span class="n">itervalues</span><span class="p">()])</span>
        <span class="k">if</span> <span class="n">norm</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">())</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">H</span> <span class="o">/</span> <span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">H</span></div>
<div class="viewcode-block" id="Chain.mfpt_to"><a class="viewcode-back" href="../getting_started.html#pykov.Chain.mfpt_to">[docs]</a>    <span class="k">def</span> <span class="nf">mfpt_to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
    <span class="c">#def mfpt_to(self, state, error=1e-08, guess=None):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the Mean First Passage Times of every state to the indicated</span>
<span class="sd">        state.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">           Kemeny J. G.; Snell, J. L.</span>
<span class="sd">           Finite Markov Chains.</span>
<span class="sd">           Springer-Verlag: New York, 1976.</span>

<span class="sd">        &gt;&gt;&gt; d = {(&#39;R&#39;, &#39;N&#39;): 0.25, (&#39;R&#39;, &#39;S&#39;): 0.25, (&#39;S&#39;, &#39;R&#39;): 0.25,</span>
<span class="sd">                 (&#39;R&#39;, &#39;R&#39;): 0.5, (&#39;N&#39;, &#39;S&#39;): 0.5, (&#39;S&#39;, &#39;S&#39;): 0.5,</span>
<span class="sd">                 (&#39;S&#39;, &#39;N&#39;): 0.25, (&#39;N&#39;, &#39;R&#39;): 0.5, (&#39;N&#39;, &#39;N&#39;): 0.0}</span>
<span class="sd">        &gt;&gt;&gt; T = pykov.Chain(d)</span>
<span class="sd">        &gt;&gt;&gt; T.mfpt_to(&#39;R&#39;)</span>
<span class="sd">        {&#39;S&#39;: 3.333333333333333, &#39;N&#39;: 2.666666666666667}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">())</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">()</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
            <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">()</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">()</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">()</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">Vector</span><span class="p">({</span><span class="n">other</span><span class="p">:</span> <span class="mf">1.</span> <span class="o">/</span> <span class="bp">self</span><span class="p">[</span><span class="n">other</span><span class="p">,</span><span class="n">state</span><span class="p">]})</span>
        <span class="n">T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">([</span><span class="n">state</span><span class="p">])</span>
        <span class="n">T</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">eye</span><span class="p">()</span> <span class="o">-</span> <span class="n">T</span>
        <span class="k">return</span> <span class="n">T</span><span class="o">.</span><span class="n">_UMPFPACKSolve</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">ones</span><span class="p">())</span>
        <span class="c">#return  T._BiCGSTAB(T.ones(), error=error, x=guess)</span></div>
<div class="viewcode-block" id="Chain.adiacence"><a class="viewcode-back" href="../getting_started.html#pykov.Chain.adiacence">[docs]</a>    <span class="k">def</span> <span class="nf">adiacence</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the adiacence matrix.</span>

<span class="sd">        &gt;&gt;&gt; T = pykov.Chain({(&#39;A&#39;,&#39;B&#39;): .3, (&#39;A&#39;,&#39;A&#39;): .7, (&#39;B&#39;,&#39;A&#39;): 1.})</span>
<span class="sd">        &gt;&gt;&gt; T.adiacence()</span>
<span class="sd">        {(&#39;B&#39;, &#39;A&#39;): 1, (&#39;A&#39;, &#39;B&#39;): 1, (&#39;A&#39;, &#39;A&#39;): 1}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Matrix</span><span class="p">(</span><span class="nb">dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span></div>
<div class="viewcode-block" id="Chain.walk"><a class="viewcode-back" href="../getting_started.html#pykov.Chain.walk">[docs]</a>    <span class="k">def</span> <span class="nf">walk</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">steps</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a random walk of n steps, starting and stopping at the</span>
<span class="sd">        indicated states.</span>
<span class="sd">        </span>
<span class="sd">        .. note::</span>

<span class="sd">           If not indicated, then the starting state is chosen according</span>
<span class="sd">           to its steady probability.</span>
<span class="sd">           If the stopping state is reached before to do n steps, then the walker</span>
<span class="sd">           stops.</span>

<span class="sd">        &gt;&gt;&gt; T = pykov.Chain({(&#39;A&#39;,&#39;B&#39;): .3, (&#39;A&#39;,&#39;A&#39;): .7, (&#39;B&#39;,&#39;A&#39;): 1.})</span>
<span class="sd">        &gt;&gt;&gt; T.walk(10)</span>
<span class="sd">        [&#39;B&#39;, &#39;A&#39;, &#39;B&#39;, &#39;A&#39;, &#39;A&#39;, &#39;B&#39;, &#39;A&#39;, &#39;A&#39;, &#39;A&#39;, &#39;B&#39;, &#39;A&#39;]</span>
<span class="sd">        &gt;&gt;&gt; T.walk(10,&#39;B&#39;,&#39;B&#39;)</span>
<span class="sd">        [&#39;B&#39;, &#39;A&#39;, &#39;A&#39;, &#39;A&#39;, &#39;A&#39;, &#39;A&#39;, &#39;B&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">start</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">steady</span><span class="p">()</span><span class="o">.</span><span class="n">choose</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">stop</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">start</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">steps</span><span class="p">):</span>
                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="k">if</span> <span class="n">stop</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">start</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">steps</span><span class="p">):</span>
                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
                <span class="k">if</span> <span class="n">result</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">stop</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">result</span>
            <span class="k">return</span> <span class="n">result</span></div>
<div class="viewcode-block" id="Chain.walk_probability"><a class="viewcode-back" href="../getting_started.html#pykov.Chain.walk_probability">[docs]</a>    <span class="k">def</span> <span class="nf">walk_probability</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">walk</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a walk, return the log of its probability.</span>

<span class="sd">        &gt;&gt;&gt; T = pykov.Chain({(&#39;A&#39;,&#39;B&#39;): .3, (&#39;A&#39;,&#39;A&#39;): .7, (&#39;B&#39;,&#39;A&#39;): 1.})</span>
<span class="sd">        &gt;&gt;&gt; T.walk_probability([&#39;A&#39;,&#39;A&#39;,&#39;B&#39;,&#39;A&#39;,&#39;A&#39;])</span>
<span class="sd">        -1.917322692203401</span>
<span class="sd">        &gt;&gt;&gt; probability = math.exp(-1.917322692203401)</span>
<span class="sd">        0.147</span>
<span class="sd">        &gt;&gt;&gt; p = T.walk_probability([&#39;A&#39;,&#39;B&#39;,&#39;B&#39;,&#39;B&#39;,&#39;A&#39;])</span>
<span class="sd">        &gt;&gt;&gt; math.exp(p)</span>
<span class="sd">        0.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">walk</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">walk</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">[</span><span class="n">step</span><span class="p">]:</span>
                <span class="k">return</span> <span class="o">-</span><span class="nb">float</span><span class="p">(</span><span class="s">&#39;Inf&#39;</span><span class="p">)</span>
            <span class="n">res</span> <span class="o">+=</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">step</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">res</span>
<span class="c">#    def not_reversible(self):</span>
<span class="c">#        &quot;&quot;&quot;</span>
<span class="c">#        (Heuristic) Return a float value between 1 and 0, where 0 means that the Chain is reversible.</span>
<span class="c">#        &quot;&quot;&quot;</span>
<span class="c">#        res = 0</span>
<span class="c">#        S = set()</span>
<span class="c">#        pi = self.steady()</span>
<span class="c">#        for link in self:</span>
<span class="c">#            if link not in S:</span>
<span class="c">#                S.add(link)</span>
<span class="c">#                S.add((link[1],link[0]))</span>
<span class="c">#                res += abs(pi[link[0]] * self[link] -</span>
<span class="c">#                           pi[link[1]] * self[(link[1],link[0])]</span>
<span class="c">#                          )</span>
<span class="c">#        return res</span></div>
<div class="viewcode-block" id="Chain.mixing_time"><a class="viewcode-back" href="../getting_started.html#pykov.Chain.mixing_time">[docs]</a>    <span class="k">def</span> <span class="nf">mixing_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=.</span><span class="mi">25</span><span class="p">,</span> <span class="n">jump</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the mixing time.</span>

<span class="sd">        If the initial distribution (p) is not indicated,</span>
<span class="sd">        then it is set to p={&#39;less probable state&#39;:1}.</span>

<span class="sd">        .. note::</span>
<span class="sd">        </span>
<span class="sd">           The mixing time is calculated here as the number of steps (n) needed to</span>
<span class="sd">           have</span>

<span class="sd">           .. math::</span>

<span class="sd">              |p(n)-\pi| &lt; 0.25</span>
<span class="sd">              </span>
<span class="sd">              p(n)=p P^n</span>
<span class="sd">              </span>
<span class="sd">              \pi=\pi P</span>
<span class="sd">           ..</span>

<span class="sd">           The parameter ``jump`` controls the iteration step, for example with</span>
<span class="sd">           ``jump=2`` n has values 2,4,6,8,..</span>
<span class="sd">        ..</span>

<span class="sd">        &gt;&gt;&gt; d = {(&#39;R&#39;,&#39;R&#39;):1./2, (&#39;R&#39;,&#39;N&#39;):1./4, (&#39;R&#39;,&#39;S&#39;):1./4,</span>
<span class="sd">                 (&#39;N&#39;,&#39;R&#39;):1./2, (&#39;N&#39;,&#39;N&#39;):0., (&#39;N&#39;,&#39;S&#39;):1./2,</span>
<span class="sd">                 (&#39;S&#39;,&#39;R&#39;):1./4, (&#39;S&#39;,&#39;N&#39;):1./4, (&#39;S&#39;,&#39;S&#39;):1./2}</span>
<span class="sd">        &gt;&gt;&gt; T = pykov.Chain(d)</span>
<span class="sd">        &gt;&gt;&gt; T.mixing_time()</span>
<span class="sd">        2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">d</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">p</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">({</span><span class="bp">self</span><span class="o">.</span><span class="n">steady</span><span class="p">()</span><span class="o">.</span><span class="n">sort</span><span class="p">()[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span><span class="mi">1</span><span class="p">})</span>
        <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">dist</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">steady</span><span class="p">()))</span>
        <span class="c">##res.append(p.relative_entropy(self.steady()))</span>
        <span class="k">while</span> <span class="n">d</span> <span class="o">&gt;</span> <span class="n">cutoff</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">+</span> <span class="n">jump</span>
            <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">jump</span><span class="p">)</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">dist</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">steady</span><span class="p">())</span>
            <span class="c">##d = p.relative_entropy(self.steady())</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="c">#return n, [range(0,n+1,jump),res]</span>
        <span class="k">return</span> <span class="n">n</span></div>
<div class="viewcode-block" id="Chain.absorbing_time"><a class="viewcode-back" href="../getting_started.html#pykov.Chain.absorbing_time">[docs]</a>    <span class="k">def</span> <span class="nf">absorbing_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transient_set</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Mean number of steps needed to leave the transient set.</span>

<span class="sd">        Return the ``Vector tau``, the ``tau[i]`` is the mean number of steps needed</span>
<span class="sd">        to leave the transient set starting from state ``i``. The parameter</span>
<span class="sd">        ``transient_set`` is a subset of nodes.</span>
<span class="sd">        </span>
<span class="sd">        .. note::</span>
<span class="sd">           </span>
<span class="sd">           If the starting point is a ``Vector p``, then it is sufficient to</span>
<span class="sd">           calculate ``p * tau`` in order to weigh the mean times according the</span>
<span class="sd">           initial conditions.</span>


<span class="sd">        .. seealso:</span>
<span class="sd">           </span>
<span class="sd">           Kemeny J. G.; Snell, J. L. </span>
<span class="sd">           Finite Markov Chains.</span>
<span class="sd">           Springer-Verlag: New York, 1976.</span>

<span class="sd">        &gt;&gt;&gt; d = {(&#39;R&#39;,&#39;R&#39;):1./2, (&#39;R&#39;,&#39;N&#39;):1./4, (&#39;R&#39;,&#39;S&#39;):1./4,</span>
<span class="sd">                 (&#39;N&#39;,&#39;R&#39;):1./2, (&#39;N&#39;,&#39;N&#39;):0., (&#39;N&#39;,&#39;S&#39;):1./2,</span>
<span class="sd">                 (&#39;S&#39;,&#39;R&#39;):1./4, (&#39;S&#39;,&#39;N&#39;):1./4, (&#39;S&#39;,&#39;S&#39;):1./2}</span>
<span class="sd">        &gt;&gt;&gt; T = pykov.Chain(d)</span>
<span class="sd">        &gt;&gt;&gt; p = pykov.Vector({&#39;N&#39;:.3, &#39;S&#39;:.7})</span>
<span class="sd">        &gt;&gt;&gt; tau = T.absorbing_time(p.keys())</span>
<span class="sd">        &gt;&gt;&gt; p * tau</span>
<span class="sd">        3.1333333333333329</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">()</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">transient_set</span><span class="p">))</span> 
        <span class="n">K</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">eye</span><span class="p">()</span> <span class="o">-</span> <span class="n">Q</span>
        <span class="c">#means</span>
        <span class="n">tau</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">_UMPFPACKSolve</span><span class="p">(</span><span class="n">K</span><span class="o">.</span><span class="n">ones</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">tau</span>
        <span class="c">#-----</span>
        <span class="c">#variances</span>
        <span class="c">#Ntau = K._UMPFPACKSolve(tau)</span>
        <span class="c">#tau_square = Vector({})</span>
        <span class="c">#for k,v in tau.iteritems():</span>
        <span class="c">#    tau_square[k] = v**2</span>
        <span class="c">#var_tau = 2 * Ntau - tau - tau_square</span>
        <span class="c">#--------</span>
        <span class="c">#return tau, var_tau</span></div>
<div class="viewcode-block" id="Chain.absorbing_tour"><a class="viewcode-back" href="../getting_started.html#pykov.Chain.absorbing_tour">[docs]</a>    <span class="k">def</span> <span class="nf">absorbing_tour</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">transient_set</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a ``Vector v``, ``v[i]`` is the mean of the total number of times</span>
<span class="sd">        the process is in a given transient state ``i`` before to leave the</span>
<span class="sd">        transient set.</span>
<span class="sd">        </span>
<span class="sd">        .. note::</span>
<span class="sd">           ``v.sum()`` is equal to ``p * tau`` (see :meth:`absorbing_time` method).</span>

<span class="sd">        In not specified, the ``transient set`` (with its probability) is defined</span>
<span class="sd">        by means of the ``Vector p``.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">           Kemeny J. G.; Snell, J. L. </span>
<span class="sd">           Finite Markov Chains.</span>
<span class="sd">           Springer-Verlag: New York, 1976.</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; d = {(&#39;R&#39;,&#39;R&#39;):1./2, (&#39;R&#39;,&#39;N&#39;):1./4, (&#39;R&#39;,&#39;S&#39;):1./4,</span>
<span class="sd">                 (&#39;N&#39;,&#39;R&#39;):1./2, (&#39;N&#39;,&#39;N&#39;):0., (&#39;N&#39;,&#39;S&#39;):1./2,</span>
<span class="sd">                 (&#39;S&#39;,&#39;R&#39;):1./4, (&#39;S&#39;,&#39;N&#39;):1./4, (&#39;S&#39;,&#39;S&#39;):1./2}</span>
<span class="sd">        &gt;&gt;&gt; T = pykov.Chain(d)</span>
<span class="sd">        &gt;&gt;&gt; p = pykov.Vector({&#39;N&#39;:.3, &#39;S&#39;:.7})</span>
<span class="sd">        &gt;&gt;&gt; T.absorbing_tour(p)</span>
<span class="sd">        {&#39;S&#39;: 2.2666666666666666, &#39;N&#39;: 0.8666666666666669}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">transient_set</span><span class="p">:</span>
            <span class="n">Q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">()</span> <span class="o">-</span> <span class="n">transient_set</span><span class="p">)</span> 
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">()</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
        <span class="n">K</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">eye</span><span class="p">()</span> <span class="o">-</span> <span class="n">Q</span>
        <span class="k">return</span> <span class="n">K</span><span class="o">.</span><span class="n">_UMPFPACKSolve</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">method</span><span class="o">=</span><span class="s">&#39;UMFPACK_At&#39;</span><span class="p">)</span></div>
<div class="viewcode-block" id="Chain.fundamental_matrix"><a class="viewcode-back" href="../getting_started.html#pykov.Chain.fundamental_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">fundamental_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the fundamental matrix.</span>

<span class="sd">        .. seealso::</span>
<span class="sd">        </span>
<span class="sd">           Kemeny J. G.; Snell, J. L. </span>
<span class="sd">           Finite Markov Chains.</span>
<span class="sd">           Springer-Verlag: New York, 1976.</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; T = pykov.Chain({(&#39;A&#39;,&#39;B&#39;): .3, (&#39;A&#39;,&#39;A&#39;): .7, (&#39;B&#39;,&#39;A&#39;): 1.})</span>
<span class="sd">        &gt;&gt;&gt; T.fundamental_matrix()</span>
<span class="sd">        {(&#39;B&#39;, &#39;A&#39;): 0.17751479289940991, (&#39;A&#39;, &#39;B&#39;): 0.053254437869822958,</span>
<span class="sd">        (&#39;A&#39;, &#39;A&#39;): 0.94674556213017902, (&#39;B&#39;, &#39;B&#39;): 0.82248520710059214}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fundamental_matrix</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">el2pos</span><span class="p">,</span> <span class="n">pos2el</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_el2pos_</span><span class="p">()</span>
            <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">steady</span><span class="p">()</span><span class="o">.</span><span class="n">_toarray</span><span class="p">(</span><span class="n">el2pos</span><span class="p">)</span>        
            <span class="n">P</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_numpy_mat</span><span class="p">(</span><span class="n">el2pos</span><span class="p">)</span>
            <span class="n">d</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">matrix</span><span class="p">([</span><span class="n">p</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">d</span><span class="p">)])</span>
            <span class="n">I</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">d</span><span class="p">))</span>
            <span class="n">E</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">)))</span>
            <span class="n">D</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span>
            <span class="n">diag</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">p</span>
            <span class="k">for</span> <span class="n">pos</span><span class="p">,</span><span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">diag</span><span class="p">):</span>
                <span class="n">D</span><span class="p">[</span><span class="n">pos</span><span class="p">,</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
            <span class="n">Z</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">I</span> <span class="o">-</span> <span class="n">P</span> <span class="o">+</span> <span class="n">A</span><span class="p">)</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">()</span>
            <span class="n">res</span><span class="o">.</span><span class="n">_from_numpy_mat</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span><span class="n">pos2el</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_fundamental_matrix</span> <span class="o">=</span> <span class="n">res</span>
            <span class="k">return</span> <span class="n">res</span></div>
<div class="viewcode-block" id="Chain.kemeny_constant"><a class="viewcode-back" href="../getting_started.html#pykov.Chain.kemeny_constant">[docs]</a>    <span class="k">def</span> <span class="nf">kemeny_constant</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the Kemeny constant of the transition matrix.</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; T = pykov.Chain({(&#39;A&#39;,&#39;B&#39;): .3, (&#39;A&#39;,&#39;A&#39;): .7, (&#39;B&#39;,&#39;A&#39;): 1.})</span>
<span class="sd">        &gt;&gt;&gt; T.Kemeny_constant()</span>
<span class="sd">        1.7692307692307712</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fundamental_matrix</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">Z</span><span class="o">.</span><span class="n">trace</span><span class="p">()</span>
        <span class="c">#K = 0.</span>
        <span class="c">#for state in self.states():</span>
        <span class="c">#    K = K + Z.get((state, state), 0)</span>
        <span class="c">#return K</span>
<span class="c">#    def force_detailed_balance(self):</span>
<span class="c">#        &quot;&quot;&quot;</span>
<span class="c">#        (Heuristic) Return a new Chain, which satisfies detailed balance.</span>
<span class="c">#</span>
<span class="c">#        Maths</span>
<span class="c">#        -----</span>
<span class="c">#        q_ij_db = q_ji_db = (pi_i * T_ij + pi_j * T_ji) / 2</span>
<span class="c">#        pi_i_db = sum_j q_ij_db</span>
<span class="c">#        Tij_db = q_ij_db / pi_i_db</span>
<span class="c">#        &quot;&quot;&quot;</span>
<span class="c">#        tij = {}</span>
<span class="c">#        pi = self.steady()</span>
<span class="c">#        for key in self.iterkeys():</span>
<span class="c">#            if key not in tij:</span>
<span class="c">#                num = (pi[key[0]] * self[key] +</span>
<span class="c">#                       pi[key[1]] * self[(key[1],key[0])])</span>
<span class="c">#                den = (pi[key[0]] +</span>
<span class="c">#                       sum([pi[k] * v for k,v in self.pred(key[0]).iteritems()]))</span>
<span class="c">#                tij[key] = num/den</span>
<span class="c">#                den = (pi[key[1]] +</span>
<span class="c">#                       sum([pi[k] * v for k,v in self.pred(key[1]).iteritems()]))</span>
<span class="c">#                tij[(key[1],key[0])] = num/den</span>
<span class="c">#        return Chain(tij)</span>
<span class="c">#    def cFEP(self, node, p=None, temp=None):</span>
<span class="c">#        &quot;&quot;&quot;</span>
<span class="c">#        (Heuristic) Return the cut based free energy profile.</span>
<span class="c">#    </span>
<span class="c">#        Mfpt ordering.</span>
<span class="c">#        Return a list of lists:</span>
<span class="c">#        [[node, mfpt, p_A, p_AB, -KTlog(P_AB), -KTlog(P_AB/P_A)],</span>
<span class="c">#        [...],</span>
<span class="c">#        ...]</span>
<span class="c">#    </span>
<span class="c">#        -- Parameters --</span>
<span class="c">#        chain : a Chain object</span>
<span class="c">#        p_i : the steady state of the chain</span>
<span class="c">#        node : the reference node</span>
<span class="c">#        temp : the temperature (if None, KT is set to 1)</span>
<span class="c">#        &quot;&quot;&quot;</span>
<span class="c">#        if not temp:</span>
<span class="c">#            KT = 1</span>
<span class="c">#        else:</span>
<span class="c">#            KB = 1.987E-3 #Boltzman constant in kCal/(mol K)</span>
<span class="c">#            KT=temp*KB</span>
<span class="c">#        if not p:</span>
<span class="c">#            p = self.steady()</span>
<span class="c">#        #p_ij = {}</span>
<span class="c">#        #for k, v in self.iteritems():</span>
<span class="c">#        #    p_ij[k] = p[k[0]] * v</span>
<span class="c">#        mfptnode = self.mfpt_to(node)</span>
<span class="c">#        result = [[node, 0.]]</span>
<span class="c">#        result.extend([list(i) for i in mfptnode.sort()])</span>
<span class="c">#        A = set()</span>
<span class="c">#        C = set()</span>
<span class="c">#        p_A = 0.</span>
<span class="c">#        for data in result[:-1]:</span>
<span class="c">#            p_A = p_A +p[data[0]]</span>
<span class="c">#            A = A | set([data[0]])</span>
<span class="c">#            C = C | set(self.succ(data[0]).keys())</span>
<span class="c">#            C = C - A</span>
<span class="c">#            p_AB = 0.</span>
<span class="c">#            for i in C:</span>
<span class="c">#                for j in set(self.pred(i).keys()):</span>
<span class="c">#                    if j in A:</span>
<span class="c">#                        #p_AB = p_AB + p_ij[(j,i)]</span>
<span class="c">#                        p_AB = p_AB + p[j] * self[j,i]</span>
<span class="c">#            data.append(p_A)</span>
<span class="c">#            data.append(p_AB)</span>
<span class="c">#            data.append(-KT * math.log(p_AB))</span>
<span class="c">#            data.append(-KT * math.log(p_AB / p_A))</span>
<span class="c">#        return result</span>
<span class="c">#    def graph(self, attribute_data=None):</span>
<span class="c">#        &quot;&quot;&quot;</span>
<span class="c">#        Return the associated directed graph as a networkx.DiGraph object.</span>
<span class="c">#        </span>
<span class="c">#        Paramenters</span>
<span class="c">#        -----------</span>
<span class="c">#        attribute : a dict keyed by links an valued by an python objects.</span>
<span class="c">#</span>
<span class="c">#        Example</span>
<span class="c">#        -------</span>
<span class="c">#        &gt;&gt;&gt; T = pykov.Chain({(&#39;A&#39;,&#39;B&#39;): .3, (&#39;A&#39;,&#39;A&#39;): .7, (&#39;B&#39;,&#39;A&#39;): 1.})</span>
<span class="c">#        &gt;&gt;&gt; G = T.graph()</span>
<span class="c">#        &gt;&gt;&gt; G.edges()</span>
<span class="c">#        [(&#39;A&#39;, &#39;A&#39;), (&#39;A&#39;, &#39;B&#39;), (&#39;B&#39;, &#39;A&#39;)]</span>
<span class="c">#        &quot;&quot;&quot;</span>
<span class="c">#        G = networkx.DiGraph()</span>
<span class="c">#        if not attribute_data:</span>
<span class="c">#            for k1, k2 in self:</span>
<span class="c">#                G.add_edge(k1, k2)</span>
<span class="c">#        else:</span>
<span class="c">#            for k1, k2 in self:</span>
<span class="c">#                G.add_edge(k1, k2, attribute = attribute_data[(k1,k2)])</span>
<span class="c">#        return G</span>
<span class="c">#    def irreducible_components(self):</span>
<span class="c">#        &quot;&quot;&quot;</span>
<span class="c">#        Return the irredicible (i.e. strongly connected) components, ordered in size.</span>
<span class="c">#</span>
<span class="c">#        Example</span>
<span class="c">#        -------</span>
<span class="c">#        &gt;&gt;&gt; d = {(&#39;R&#39;,&#39;R&#39;):1./2, (&#39;R&#39;,&#39;N&#39;):1./4, (&#39;R&#39;,&#39;S&#39;):1./4,</span>
<span class="c">#                  (&#39;N&#39;,&#39;N&#39;):1./2, (&#39;N&#39;,&#39;S&#39;):1./2, (&#39;S&#39;,&#39;N&#39;):1./2, (&#39;S&#39;,&#39;S&#39;):1./2}</span>
<span class="c">#        &gt;&gt;&gt; T = pykov.Chain(d)</span>
<span class="c">#        &gt;&gt;&gt; T.irredicible_components()</span>
<span class="c">#        [[&#39;N&#39;, &#39;S&#39;], [&#39;R&#39;]]</span>
<span class="c">#</span>
<span class="c">#        References</span>
<span class="c">#        ----------</span>
<span class="c">#        The function calls networkx.strongly_connected_components().</span>
<span class="c">#        &quot;&quot;&quot;</span>
<span class="c">#        G = self.graph()</span>
<span class="c">#        return networkx.strongly_connected_components(G)</span>
<span class="c">#    def extract_irreducible_component(self,component):</span>
<span class="c">#        &quot;&quot;&quot;</span>
<span class="c">#        Return the Chain associated to the indicated irreducible component.</span>
<span class="c">#</span>
<span class="c">#        An operation of normalization is imposed (see stochastic method).</span>
<span class="c">#        &quot;&quot;&quot;</span>
<span class="c">#        res = self.remove(self.states() - set(component))</span>
<span class="c">#        res = Chain(res)</span>
<span class="c">#        res.stochastic()</span>
<span class="c">#        return res</span>
<span class="c">#    def test_detailed_balance(self):</span>
<span class="c">#        &quot;&quot;&quot;</span>
<span class="c">#        &quot;&quot;&quot;</span>
<span class="c">#        p = self.steady()</span>
<span class="c">#        result = 0</span>
<span class="c">#        for k1, k2 in self.iterkeys():</span>
<span class="c">#            result += abs(p[k1] * T[k1,k2] - p[k2] * T[k2,k1])</span>
<span class="c">#        return result/2.</span>
<span class="c">#    def fundamental_matrix_col(self, state):</span>
<span class="c">#        &quot;&quot;&quot;</span>
<span class="c">#        &quot;&quot;&quot;</span>
<span class="c">#        A = Matrix()</span>
<span class="c">#        for i in self.states():</span>
<span class="c">#            for j in self.states():</span>
<span class="c">#                A[i,j] = self.steady()[j]</span>
<span class="c">#        L = self.eye() - self + A</span>
<span class="c">#        x = L._BiCGSTAB(Vector({state:1.}), error=1e-08, x=None)</span>
<span class="c">#        return x</span>
<span class="c">#    def fundamental_matrix_row(self, state):</span>
<span class="c">#        &quot;&quot;&quot;</span>
<span class="c">#        &quot;&quot;&quot;</span>
<span class="c">#        A = Matrix()</span>
<span class="c">#        for i in self.states():</span>
<span class="c">#            for j in self.states():</span>
<span class="c">#                A[i,j] = self.steady()[j]</span>
<span class="c">#        L = self.eye() - self + A</span>
<span class="c">#        L = L.transpose()</span>
<span class="c">#        x = L._BiCGSTAB(Vector({state:1.}), error=1e-08, x=None)</span>
<span class="c">#        return x</span>
<span class="c">#    def mfpt_to1(self, state):</span>
<span class="c">#        &quot;&quot;&quot;</span>
<span class="c">#        &quot;&quot;&quot;</span>
<span class="c">#        pi = self.steady()</span>
<span class="c">#        Z_state = self.fundamental_matrix_col(state)</span>
<span class="c">#        result = Vector({i:Z_state[state]-Z_state[i] for i in Z_state})</span>
<span class="c">#        return Vector({state:1./pi[state]}) + 1./pi[state] * result</span>
<span class="c">#</span>
</div></div>
<span class="k">def</span> <span class="nf">readmat</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Read an external file and return a Chain.</span>

<span class="sd">    The file must be of the form:</span>

<span class="sd">    A A .7</span>
<span class="sd">    A B .3</span>
<span class="sd">    B A 1</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; P = pykov.readmat(&#39;/mypath/mat&#39;)</span>
<span class="sd">    &gt;&gt;&gt; P</span>
<span class="sd">    {(&#39;B&#39;, &#39;A&#39;): 1.0, (&#39;A&#39;, &#39;B&#39;): 0.3, (&#39;A&#39;, &#39;A&#39;): 0.7}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">P</span> <span class="o">=</span> <span class="n">Chain</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
            <span class="n">P</span><span class="p">[(</span><span class="n">tmp</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">tmp</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">tmp</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>    
        <span class="k">return</span> <span class="n">P</span>
<span class="k">def</span> <span class="nf">readtrj</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Read an external file and return a tuple.</span>
<span class="sd">    </span>
<span class="sd">    The file must be of the form:</span>
<span class="sd">    </span>
<span class="sd">    x</span>
<span class="sd">    y</span>
<span class="sd">    z</span>
<span class="sd">    .</span>
<span class="sd">    .</span>
<span class="sd">    .</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; t = pykov.readtrj(&#39;/mypath/trj&#39;)</span>
<span class="sd">    &gt;&gt;&gt; p, T = maximum_likelihood_probabilities(t)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_writefile</span><span class="p">(</span><span class="n">mylist</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Export in a file the list.</span>

<span class="sd">    mylist could be a list of list.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; L = [[2,3],[4,5]]</span>
<span class="sd">    &gt;&gt;&gt; pykov.writefile(L,&#39;tmp&#39;)</span>
<span class="sd">    &gt;&gt;&gt; l = [1,2]</span>
<span class="sd">    &gt;&gt;&gt; pykov.writefile(l,&#39;tmp&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">L</span> <span class="o">=</span> <span class="p">[[</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">line</span><span class="p">]</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">mylist</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="n">L</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">mylist</span><span class="p">]</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\t</span><span class="s">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">L</span><span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">None</span>
<span class="k">def</span> <span class="nf">transitions</span><span class="p">(</span><span class="n">trj</span><span class="p">,</span> <span class="n">nsteps</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">lag_time</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">separator</span><span class="o">=</span><span class="s">&#39;0&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the temporal list of transitions observed.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    trj : the symbolic trajectory.</span>
<span class="sd">    nsteps : number of steps.</span>
<span class="sd">    lag_time : step length.</span>
<span class="sd">    separator: the special symbol indicating the presence of sub-trajectories.</span>
<span class="sd">    </span>
<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; trj = [1,2,1,0,2,3,1,0,2,3,2,3,1,2,3]</span>
<span class="sd">    &gt;&gt;&gt; pykov.transitions(trj,1,1,0)</span>
<span class="sd">    [(1, 2), (2, 1), (2, 3), (3, 1), (2, 3), (3, 2), (2, 3), (3, 1), (1, 2),</span>
<span class="sd">    (2, 3)]</span>
<span class="sd">    &gt;&gt;&gt; pykov.transitions(trj,1,2,0)</span>
<span class="sd">    [(1, 1), (2, 1), (2, 2), (3, 3), (2, 1), (3, 2), (1, 3)]</span>
<span class="sd">    &gt;&gt;&gt; pykov.transitions(trj,2,2,0)</span>
<span class="sd">    [(2, 2, 1), (3, 3, 2), (2, 1, 3)]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="nb">len</span><span class="p">(</span><span class="n">trj</span><span class="p">)</span> <span class="o">-</span> <span class="n">nsteps</span> <span class="o">*</span> <span class="n">lag_time</span> <span class="p">):</span>
        <span class="k">if</span> <span class="n">separator</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">trj</span><span class="p">[</span><span class="n">pos</span><span class="p">:(</span><span class="n">pos</span> <span class="o">+</span> <span class="n">nsteps</span> <span class="o">*</span> <span class="n">lag_time</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">trj</span><span class="p">[</span><span class="n">pos</span><span class="p">:(</span><span class="n">pos</span> <span class="o">+</span> <span class="n">nsteps</span> <span class="o">*</span> <span class="n">lag_time</span> <span class="o">+</span><span class="mi">1</span><span class="p">):</span><span class="n">lag_time</span><span class="p">]</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">tmp</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">result</span>
<span class="k">def</span> <span class="nf">maximum_likelihood_probabilities</span><span class="p">(</span><span class="n">trj</span><span class="p">,</span> <span class="n">lag_time</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">separator</span><span class="o">=</span><span class="s">&#39;0&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a Chain calculated by means of maximum likelihood probabilities.</span>
<span class="sd">    </span>
<span class="sd">    Return two objects:</span>
<span class="sd">    p : a Vector object, the probability distribution over the nodes.</span>
<span class="sd">    T : a Chain object, the Markov chain.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    trj : the symbolic trajectory.</span>
<span class="sd">    lag_time : number of steps defining a transition.</span>
<span class="sd">    separator: the special symbol indicating the presence of sub-trajectories.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; t = [1,2,3,2,3,2,1,2,2,3,3,2]</span>
<span class="sd">    &gt;&gt;&gt; p, T = pykov.maximum_likelihood_probabilities(t)</span>
<span class="sd">    &gt;&gt;&gt; p</span>
<span class="sd">    {1: 0.18181818181818182, 2: 0.4545454545454546, 3: 0.36363636363636365}</span>
<span class="sd">    &gt;&gt;&gt; T</span>
<span class="sd">    {(1, 2): 1.0, (3, 2): 0.7499999999999999, (2, 3): 0.5999999999999999, (3,</span>
<span class="sd">    3): 0.25, (2, 2): 0.19999999999999998, (2, 1): 0.19999999999999998}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">q_ij</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">tr</span> <span class="o">=</span> <span class="n">transitions</span><span class="p">(</span><span class="n">trj</span><span class="p">,</span> <span class="n">nsteps</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">lag_time</span><span class="o">=</span><span class="n">lag_time</span><span class="p">,</span> <span class="n">separator</span><span class="o">=</span><span class="n">separator</span><span class="p">)</span>
    <span class="n">_remove_dead_branch</span><span class="p">(</span><span class="n">tr</span><span class="p">)</span>
    <span class="n">tot</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tr</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="n">tr</span><span class="p">:</span>
            <span class="n">q_ij</span><span class="p">[</span><span class="n">step</span><span class="p">]</span> <span class="o">=</span> <span class="n">q_ij</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">step</span><span class="p">,</span> <span class="mf">0.</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">q_ij</span><span class="o">.</span><span class="n">iterkeys</span><span class="p">():</span>
        <span class="n">q_ij</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">q_ij</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">/</span> <span class="n">tot</span>
    <span class="n">p_i</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">q_ij</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
        <span class="n">p_i</span><span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">p_i</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">v</span>
    <span class="n">t_ij</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">q_ij</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
        <span class="n">t_ij</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span> <span class="o">/</span> <span class="n">p_i</span><span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">Chain</span><span class="p">(</span><span class="n">t_ij</span><span class="p">)</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">(</span><span class="n">p_i</span><span class="p">)</span>
    <span class="n">T</span><span class="o">.</span><span class="n">_guess</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">(</span><span class="n">p_i</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">p</span><span class="p">,</span> <span class="n">T</span>
<span class="c">#def non_Markovian_flux(trj, lag_time=1, separator=&#39;0&#39;):</span>
<span class="c">#    &quot;&quot;&quot;</span>
<span class="c">#    (Heuristic) Return the non-Markovian flux.</span>
<span class="c">#</span>
<span class="c">#    It is a number between 0 and 1.</span>
<span class="c">#    0 implies markovianity</span>
<span class="c">#    1 implies not markovianity</span>
<span class="c">#</span>
<span class="c">#    Example</span>
<span class="c">#    -------</span>
<span class="c">#    &gt;&gt;&gt; t = [1,2,3,2,3,2,1,2,2,3,3,2]</span>
<span class="c">#    &gt;&gt;&gt; pykov.non_Markovian_flux(t)</span>
<span class="c">#    0.15000000000000013</span>
<span class="c">#    &quot;&quot;&quot;</span>
<span class="c">#    p, C = maximum_likelihood_probabilities(trj,</span>
<span class="c">#                   lag_time=lag_time, separator=separator)</span>
<span class="c">#    tr = set(transitions(trj, nsteps=2, lag_time=lag_time,</span>
<span class="c">#                  separator=separator))</span>
<span class="c">#    r = [p[i[0]] * C[i[0], i[1]]  * C[i[1], i[2]] for i in tr]</span>
<span class="c">#    return 1 - sum(r)</span>
<span class="k">def</span> <span class="nf">_remove_dead_branch</span><span class="p">(</span><span class="n">transitions_list</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Remove dead branchs inserting a selfloop in every node that has not</span>
<span class="sd">    outgoing links.</span>
<span class="sd">    </span>
<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; trj = [1,2,3,1,2,3,2,2,4,3,5]</span>
<span class="sd">    &gt;&gt;&gt; tr = pykov.transitions(trj, nsteps=1)</span>
<span class="sd">    &gt;&gt;&gt; tr</span>
<span class="sd">    [(1, 2), (2, 3), (3, 1), (1, 2), (2, 3), (3, 2), (2, 2), (2, 4), (4, 3),</span>
<span class="sd">    (3, 5)]</span>
<span class="sd">    &gt;&gt;&gt; pykov._remove_dead_branch(tr)</span>
<span class="sd">    &gt;&gt;&gt; tr</span>
<span class="sd">    [(1, 2), (2, 3), (3, 1), (1, 2), (2, 3), (3, 2), (2, 2), (2, 4), (4, 3),</span>
<span class="sd">    (3, 5), (5, 5)]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">head_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">tail_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="n">transitions_list</span><span class="p">:</span>
        <span class="n">head_set</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">step</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">tail_set</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">step</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">head</span> <span class="ow">in</span> <span class="n">head_set</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">head</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">tail_set</span><span class="p">:</span>
            <span class="n">transitions_list</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">head</span><span class="p">,</span> <span class="n">head</span><span class="p">))</span>
    <span class="k">return</span> <span class="bp">None</span>
<span class="k">def</span> <span class="nf">_machineEpsilon</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="nb">float</span><span class="p">):</span>
    <span class="n">machine_epsilon</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">func</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="n">func</span><span class="p">(</span><span class="n">machine_epsilon</span><span class="p">)</span> <span class="o">!=</span> <span class="n">func</span><span class="p">(</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">machine_epsilon_last</span> <span class="o">=</span> <span class="n">machine_epsilon</span>
        <span class="n">machine_epsilon</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">machine_epsilon</span><span class="p">)</span> <span class="o">/</span> <span class="n">func</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">machine_epsilon_last</span>
<span class="c">#def minfloat(guess=1.):</span>
<span class="c">#    while(guess * 0.5 != 0):</span>
<span class="c">#        guess = guess * 0.5</span>
<span class="c">#    return guess</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/logo1.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li><a href="../index.html">Pykov v1.0 documentation</a> &raquo;</li>
          <li><a href="index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012, Riccardo Scalco.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.0.1.
    </div>
  </body>
</html>